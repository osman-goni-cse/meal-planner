<!DOCTYPE html>
<html xmlns:th="http://www.thymeleaf.org">
<head th:replace="~{fragments/layout :: head}">
    <!--<meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Inter:wght@100;200;300;500;600;700;800;900&display=swap">
    <style>body { font-family: 'Inter', sans-serif !important; }</style> -->
    <style>
        /* Responsive text adjustments */
        .break-words {
            word-wrap: break-word;
            overflow-wrap: break-word;
        }
        
        .break-all {
            word-break: break-all;
            overflow-wrap: break-word;
        }
        
        /* Ensure text doesn't overflow on small screens */
        @media (max-width: 640px) {
            h1, h2, h3, h4 {
                word-break: break-word;
                hyphens: auto;
            }
        }
        
        /* Improve line height for better readability */
        .leading-tight {
            line-height: 1.1;
        }
        
        .leading-relaxed {
            line-height: 1.6;
        }
    </style>
</head>
<body class="bg-white flex flex-col min-h-screen">
    <!-- Top Navigation Bar -->
    <header class="bg-white shadow-sm fixed top-0 left-0 w-full z-50">
        <div class="container mx-auto px-5 py-4">
            <div class="flex items-center justify-between">
                <div class="flex items-center space-x-2">
                    <img src="/images/foodsi-logo-01.svg" alt="Foodsi logo" class="w-40 h-16">
                </div>
                <div class="flex items-center space-x-6">
                    <!-- Desktop Navigation -->
                    <nav class="hidden md:flex items-center space-x-6">
                        <a th:href="@{/}" class="hover:text-orange-600 cursor-pointer">Today's Menu</a>
                        <a th:href="@{/weekly-feedback}" class="text-orange-600 font-semibold border-b-2 border-orange-600 pb-1 cursor-pointer">Weekly Menu</a>
                    </nav>
                    <!-- Desktop User Profile -->
                    <div th:replace="fragments/layout :: topnav-user"></div>
                    
                    <!-- Mobile Hamburger Menu Button -->
                    <button id="mobile-menu-button" class="block md:hidden flex items-center p-2 rounded-md text-gray-600 hover:text-primary hover:bg-gray-100 focus:outline-none focus:ring-2 focus:ring-inset focus:ring-primary">
                        <i class="fa-solid fa-bars text-xl"></i>
                    </button>
                </div>
            </div>
            
            <!-- Mobile Date Selector -->
            <div class="md:hidden mt-4 pb-4 border-t border-gray-200">
                <div class="flex items-center justify-between pt-4">
                    <div class="flex items-center space-x-3">
                        <i class="text-orange-600 text-lg fa-solid fa-calendar"></i>
                        <span class="text-lg font-semibold text-gray-800" th:text="${#temporals.format(selectedDate, 'dd MMMM, yyyy')}">18 July, 2025</span>
                    </div>
                    <button id="mobile-calendar-toggle" class="flex items-center space-x-2 text-orange-600">
                        <span class="text-sm font-medium">Change Date</span>
                        <i class="fa-solid fa-chevron-down text-xs"></i>
                    </button>
                </div>
            </div>
        </div>
    </header>

    <!-- Mobile Navigation Menu - Positioned outside header -->
    <div id="mobile-menu" class="hidden md:hidden fixed top-20 right-4 z-50">
        <div class="bg-white rounded-lg shadow-lg min-w-[200px]">
            <div class="flex flex-col space-y-3 pt-4 px-4 pb-4">
                <a th:href="@{/}" class="text-gray-600 hover:text-primary cursor-pointer py-2 w-fit">Today's Menu</a>
                <a th:href="@{/weekly-feedback}" class="text-primary font-semibold border-b-2 border-primary pb-1 cursor-pointer py-2 w-fit">Weekly Menu</a>
                <div class="border-t border-gray-200 pt-3">
                    <!-- Show login for anonymous users -->
                    <a th:if="${!isAuthenticated}" th:href="@{/login}" class="hover:text-orange-600 cursor-pointer w-fit text-left py-2 flex items-center">
                        Sign In
                    </a>
                    <!-- Show logout for authenticated users -->
                    <form th:if="${isAuthenticated}" th:action="@{/logout}" method="post" class="inline">
                        <button type="submit" class="text-gray-600 hover:text-primary cursor-pointer w-fit text-left py-2 flex items-center">
                            <i class="fa-solid fa-sign-out-alt mr-2"></i>
                            Sign Out
                        </button>
                    </form>
                </div>
            </div>
        </div>
    </div>

    <!-- Mobile Calendar Modal -->
    <div id="mobile-calendar-modal" class="hidden md:hidden fixed inset-0 bg-black bg-opacity-50 z-50 flex items-center justify-center p-4">
        <div class="bg-white rounded-lg shadow-xl w-full max-w-sm">
            <div class="flex items-center justify-between p-4 border-b border-gray-200">
                <h3 class="text-lg font-semibold text-gray-800">Select Date</h3>
                <button id="close-calendar-modal" class="text-gray-500 hover:text-gray-700">
                    <i class="fa-solid fa-times text-xl"></i>
                </button>
            </div>
            <div class="p-4">
                <div class="flex items-center justify-between mb-4">
                    <h4 class="text-base font-semibold text-gray-800" th:text="${calendarMonthYear}">December 2023</h4>
                    <div class="flex space-x-2">
                        <a th:href="@{/weekly-feedback(date=${prevMonthDate})}" class="p-1 hover:bg-gray-200 rounded transition-colors">
                            <i class="text-gray-600 text-sm fas fa-chevron-left"></i>
                        </a>
                        <a th:href="@{/weekly-feedback(date=${nextMonthDate})}" class="p-1 hover:bg-gray-200 rounded transition-colors">
                            <i class="text-gray-600 text-sm fas fa-chevron-right"></i>
                        </a>
                    </div>
                </div>
                <div class="grid grid-cols-7 gap-1 text-center text-sm">
                    <!-- Days of week -->
                    <div class="p-2 text-gray-500 font-medium text-xs">S</div>
                    <div class="p-2 text-gray-500 font-medium text-xs">M</div>
                    <div class="p-2 text-gray-500 font-medium text-xs">T</div>
                    <div class="p-2 text-gray-500 font-medium text-xs">W</div>
                    <div class="p-2 text-gray-500 font-medium text-xs">T</div>
                    <div class="p-2 text-gray-500 font-medium text-xs">F</div>
                    <div class="p-2 text-gray-500 font-medium text-xs">S</div>
                    <!-- Calendar dates -->
                    <div th:each="day,iter : ${calendarDays}">
                        <a th:href="@{/weekly-feedback(date=${day.date})}"
                           th:text="${day.dayOfMonth}"
                           class="block w-8 h-8 mx-auto flex items-center justify-center transition-all duration-150 text-sm"
                           th:classappend="
                                ${day.selected} ? 'bg-primary text-white rounded-full font-bold ring-2 ring-primary' :
                                (${day.inMonth?.toString() == 'true'} ? 'text-gray-800 hover:bg-primary/10 hover:rounded-full cursor-pointer' : 'text-gray-400 hover:bg-primary/10 hover:rounded-full cursor-pointer')
                           ">
                        </a>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <main id="main-content" class="container mt-8 mx-auto pt-20 md:pt-20 px-5 pb-10 flex-grow">
        <!-- Desktop Layout -->
        <div class="hidden md:flex gap-6 items-start">
            <!-- Calendar Column -->
            <div id="calendar-column" class="w-1/4 bg-gray-50 rounded-lg shadow-sm border border-gray-200 p-5">
                <div class="flex items-center justify-between mb-4">
                    <h2 class="text-lg font-semibold text-gray-800" th:text="${calendarMonthYear}">December 2023</h2>
                    <div class="flex space-x-2">
                        <a th:href="@{/weekly-feedback(date=${prevMonthDate})}" class="p-1 hover:bg-gray-200 rounded transition-colors">
                            <i class="text-gray-600 text-sm fas fa-chevron-left"></i>
                        </a>
                        <a th:href="@{/weekly-feedback(date=${nextMonthDate})}" class="p-1 hover:bg-gray-200 rounded transition-colors">
                            <i class="text-gray-600 text-sm fas fa-chevron-right"></i>
                        </a>
                    </div>
                </div>
                <div class="grid grid-cols-7 gap-1 text-center text-sm">
                    <!-- Days of week -->
                    <div class="p-2 text-gray-500 font-medium">S</div>
                    <div class="p-2 text-gray-500 font-medium">M</div>
                    <div class="p-2 text-gray-500 font-medium">T</div>
                    <div class="p-2 text-gray-500 font-medium">W</div>
                    <div class="p-2 text-gray-500 font-medium">T</div>
                    <div class="p-2 text-gray-500 font-medium">F</div>
                    <div class="p-2 text-gray-500 font-medium">S</div>
                    <!-- Calendar dates -->
                    <div th:each="day,iter : ${calendarDays}">
                        <a th:href="@{/weekly-feedback(date=${day.date})}"
                           th:text="${day.dayOfMonth}"
                           class="block w-8 h-8 mx-auto flex items-center justify-center transition-all duration-150"
                           th:classappend="
                                ${day.selected} ? 'bg-primary text-customTomato rounded-full font-bold ring-2 ring-primary' :
                                (${day.inMonth?.toString() == 'true'} ? 'text-gray-800 hover:bg-primary/10 hover:rounded-full cursor-pointer' : 'text-gray-400 hover:bg-primary/10 hover:rounded-full cursor-pointer')
                           ">
                        </a>
                    </div>
                </div>
            </div>
            <!-- Content Column -->
            <div id="content-column" class="w-3/4 bg-white rounded-lg shadow-sm flex flex-col">
                <!-- Dish Tabs -->
                <div id="dish-tabs" class="flex items-center space-x-6 sm:space-x-8 mb-6">
                    <button th:each="dish,iter : ${dishes}" th:text="${dish.name}"
                        th:classappend="${iter.index} == ${selectedDishIndex} ? 'tab-button active-tab text-base font-semibold text-orange-600 border-b-2 border-orange-600 py-3 shadow-sm transition-all duration-200' : 'tab-button text-base font-medium hover:text-orange-600 py-3 transition-all duration-200'"
                        th:onclick="|window.location='@{/weekly-feedback(date=${selectedDate},dish=${iter.index})}'|">
                        Dish Name
                    </button>
                </div>
                <!-- Main Dish and Feedback Area -->
                <div th:if="${selectedDish != null}" id="main-dish-area" class="flex-grow flex flex-col lg:flex-row border border-gray-200 rounded-xl overflow-hidden">
                    <!-- Left Column: Dish Image and Info -->
                    <div id="dish-info-column" class="w-full lg:w-[60%] p-6 bg-white">
                        <div id="dish-image-container" class="mb-6">
                            <img class="w-full h-96 object-cover rounded-xl shadow-md" th:src="${selectedDish != null ? selectedDish.imageUrl : ''}" th:alt="${selectedDish != null ? selectedDish.name : 'Dish'}">
                        </div>
                        <div id="dish-details">
                            <div class="flex items-center justify-between mb-2">
                                <h1 class="text-2xl sm:text-3xl md:text-4xl lg:text-5xl font-bold font-dmSerifDisplay text-gray-800 break-words break-all" th:text="${selectedDish != null ? selectedDish.name : 'Dish Name'}">Dish Name</h1>
                                <span th:if="${selectedDish != null && selectedDish.mealPeriod != null}" 
                                      class="bg-blue-100 text-blue-800 px-2 py-0.5 rounded text-sm font-medium whitespace-nowrap">
                                    <span th:text="${#strings.capitalize(selectedDish.mealPeriod)}">Lunch</span>
                                </span>
                            </div>
                            <p class="text-lg text-gray-600 mt-2 leading-relaxed break-words" th:text="${selectedDish != null ? selectedDish.description : 'Dish description'}">Dish description</p>
                        </div>
                    </div>
                    <!-- Right Column: Feedback -->
                    <div id="feedback-column" class="w-full lg:w-[40%] bg-gray-50/50 border-l border-gray-200 flex flex-col p-6">
                        <div th:if="${!selectedDate.isAfter(T(java.time.LocalDate).now())}" id="comments-list" class="flex-grow space-y-5 pr-2 -mr-2 overflow-y-auto h-64">
                            <!-- Comments will be loaded here by JS -->
                        </div>
                        <div class="mt-4 pt-4 border-t border-gray-200">
                            <!-- Error message -->
                            <div th:if="${error}" class="mb-3 p-2 bg-red-100 border border-red-300 text-red-700 rounded text-sm">
                                <span th:text="${error}">Comment cannot be empty.</span>
                            </div>
                            <div th:if="${selectedDish != null && !selectedDish.isEmpty() && !selectedDate.isAfter(T(java.time.LocalDate).now())}" class="space-y-3">
                                <!-- Reaction count and comments on same line - FIRST -->
                                <div class="flex items-center">
                                    <!-- Reaction count display - left aligned -->
                                    <div id="reaction-count-display" class="flex items-center space-x-1" th:style="${selectedDish != null && selectedDish.reactions > 0} ? 'display: flex' : 'display: none'">
                                        <!-- Show reaction emojis side by side -->
                                        <div class="flex items-center">
                                            <span th:if="${selectedDish.reactionCounts != null && selectedDish.reactionCounts.DELICIOUS > 0}">üòã</span>
                                            <span th:if="${selectedDish.reactionCounts != null && selectedDish.reactionCounts.AVERAGE > 0}">üòê</span>
                                            <span th:if="${selectedDish.reactionCounts != null && selectedDish.reactionCounts.BAD > 0}">üòû</span>
                                        </div>
                                        <!-- Show total count -->
                                        <span class="text-sm text-gray-600" th:text="${selectedDish.reactions}">0</span>
                                    </div>
                                    <!-- Comments - always right aligned -->
                                    <div class="ml-auto flex items-center space-x-1.5 text-gray-600">
                                        <i class="fa-regular fa-comment text-lg text-blue-500"></i>
                                        <span class="font-medium text-sm" th:text="${selectedDish != null ? selectedDish.commentsCount : 0}">0</span>
                                        <span class="text-sm ml-1">Comments</span>
                                    </div>
                                </div>
                                <!-- Main reaction button on separate line - SECOND -->
                                <div class="flex items-center">
                                    <!-- Desktop Reaction System -->
                                    <div class="relative">
                                        <!-- Main reaction button with emoji and text -->
                                        <button id="reaction-btn" type="button" class="flex items-center space-x-1.5 text-gray-600 hover:text-gray-800 focus:outline-none transition-colors duration-200 my-2">
                                            <div class="relative flex items-center">
                                                <span id="reaction-icon" class="text-lg transition-all duration-200" 
                                                      data-reaction-type="NONE"
                                                      th:data-reaction-type="${selectedDish != null && selectedDish.userReactionType != null ? selectedDish.userReactionType : 'NONE'}">
                                                    <i th:if="${selectedDish == null || selectedDish.userReactionType == null}" class="fa-regular fa-smile text-gray-400"></i>
                                                    <span th:if="${selectedDish != null && selectedDish.userReactionType == 'DELICIOUS'}">üòã</span>
                                                    <span th:if="${selectedDish != null && selectedDish.userReactionType == 'AVERAGE'}">üòê</span>
                                                    <span th:if="${selectedDish != null && selectedDish.userReactionType == 'BAD'}">üòû</span>
                                                </span>
                                                <span id="reaction-text" class="font-medium text-sm ml-1"
                                                      th:text="${selectedDish != null && selectedDish.userReactionType == 'DELICIOUS' ? 'Delicious' : (selectedDish != null && selectedDish.userReactionType == 'AVERAGE' ? 'Average' : (selectedDish != null && selectedDish.userReactionType == 'BAD' ? 'Bad' : 'React'))}"
                                                      th:classappend="${selectedDish != null && selectedDish.userReactionType == 'DELICIOUS' ? 'text-green-600' : (selectedDish != null && selectedDish.userReactionType == 'AVERAGE' ? 'text-yellow-600' : (selectedDish != null && selectedDish.userReactionType == 'BAD' ? 'text-red-600' : 'text-gray-400'))}">
                                                    React
                                                </span>
                                            </div>
                                        </button>
                                        <!-- Facebook-style Hover Menu -->
                                        <div id="reaction-menu" class="absolute bottom-full left-0 mb-3 bg-white border border-gray-200 rounded-full shadow-xl p-2 hidden z-50 transform scale-100 transition-all duration-200">
                                            <div class="flex space-x-1">
                                                <button class="reaction-option p-2 hover:scale-125 transition-all duration-200 rounded-full hover:bg-gray-50" data-reaction="DELICIOUS" data-emoji="üòã" data-text="Delicious" title="Delicious">
                                                    <span class="text-2xl filter drop-shadow-sm">üòã</span>
                                                </button>
                                                <button class="reaction-option p-2 hover:scale-125 transition-all duration-200 rounded-full hover:bg-gray-50" data-reaction="AVERAGE" data-emoji="üòê" data-text="Average" title="Average">
                                                    <span class="text-2xl filter drop-shadow-sm">üòê</span>
                                                </button>
                                                <button class="reaction-option p-2 hover:scale-125 transition-all duration-200 rounded-full hover:bg-gray-50" data-reaction="BAD" data-emoji="üòû" data-text="Bad" title="Bad">
                                                    <span class="text-2xl filter drop-shadow-sm">üòû</span>
                                                </button>
                                            </div>
                                        </div>
                                    </div>
                                </div>
                            </div>
                            <div th:if="${!selectedDate.isAfter(T(java.time.LocalDate).now())}" id="feedback-form" class="flex items-center space-x-2">
                                <form th:action="@{/weekly-feedback/feedback}" method="post" class="flex w-full">
                                    <input type="hidden" name="date" th:value="${selectedDate}">
                                    <input type="hidden" name="dishId" th:value="${selectedDish != null ? selectedDish.id : ''}">
                                    <input type="text" name="comment" placeholder="Share your thoughts..." class="w-full px-4 mr-1 py-2 text-sm border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-primary/50 focus:border-primary transition">
                                    <button type="submit" class="bg-gray-800 text-white font-semibold px-4 py-2 rounded-lg hover:bg-gray-900 transition-colors text-sm">Submit</button>
                                </form>
                            </div>
                        </div>
                    </div>
                </div>
                <div th:if="${selectedDish == null}" class="text-center text-gray-500 py-10">
                    No dishes available for this date.
                </div>
            </div>
        </div>

        <!-- Mobile Layout -->
        <div class="md:hidden pt-32">
            <!-- Dish Tabs - Horizontally Scrollable -->
            <div id="mobile-dish-tabs" class="flex items-center space-x-6 my-8 overflow-x-auto pb-2 scrollbar-hide">
                <button th:each="dish,iter : ${dishes}" th:text="${dish.name}"
                    th:classappend="${iter.index} == ${selectedDishIndex} ? 'tab-button active-tab text-base font-semibold text-orange-600 border-b-2 border-orange-600 py-3 shadow-sm transition-all duration-200 whitespace-nowrap flex-shrink-0' : 'tab-button text-base font-medium hover:text-orange-600 py-3 transition-all duration-200 whitespace-nowrap flex-shrink-0'"
                    th:onclick="|window.location='@{/weekly-feedback(date=${selectedDate},dish=${iter.index})}'|">
                    Dish Name
                </button>
            </div>

            <!-- Mobile Dish Content -->
            <div th:if="${selectedDish != null}" class="bg-white rounded-lg shadow-sm border border-gray-200 grid grid-rows-[1fr_auto] h-[calc(100vh-200px)]">
                <!-- Dish Image - Takes available space -->
                <div class="relative min-h-0">
                    <img class="w-full h-full object-cover rounded-t-lg" th:src="${selectedDish != null ? selectedDish.imageUrl : ''}" th:alt="${selectedDish != null ? selectedDish.name : 'Dish'}">
                </div>
                
                <!-- Dish Details - Auto-sized based on content -->
                <div class="p-6">
                    <div class="flex items-center justify-between mb-3">
                        <h1 class="text-xl sm:text-2xl md:text-3xl font-bold text-gray-800 break-words" th:text="${selectedDish != null ? selectedDish.name : 'Dish Name'}">Dish Name</h1>
                        <span th:if="${selectedDish != null && selectedDish.mealPeriod != null}" 
                              class="bg-blue-100 text-blue-800 px-2 py-0.5 rounded text-sm font-medium whitespace-nowrap">
                            <span th:text="${#strings.capitalize(selectedDish.mealPeriod)}">Lunch</span>
                        </span>
                    </div>
                    <p class="text-lg text-gray-600 mb-6 leading-relaxed break-words" th:text="${selectedDish != null ? selectedDish.description : 'Dish description'}">Dish description</p>
                    
                    <!-- Likes and Comments -->
                    <div th:if="${selectedDish != null && !selectedDish.isEmpty() && !selectedDate.isAfter(T(java.time.LocalDate).now())}" class="space-y-3">
                        <!-- Mobile reaction count and comments on same line - FIRST -->
                        <div class="flex items-center">
                            <!-- Mobile reaction count display - left aligned -->
                            <div id="mobile-reaction-count-display" class="flex items-center space-x-1" th:style="${selectedDish != null && selectedDish.reactions > 0} ? 'display: flex' : 'display: none'">
                                <!-- Show reaction emojis side by side -->
                                <div class="flex items-center space-x-1">
                                    <span th:if="${selectedDish.reactionCounts != null && selectedDish.reactionCounts.DELICIOUS > 0}">üòã</span>
                                    <span th:if="${selectedDish.reactionCounts != null && selectedDish.reactionCounts.AVERAGE > 0}">üòê</span>
                                    <span th:if="${selectedDish.reactionCounts != null && selectedDish.reactionCounts.BAD > 0}">üòû</span>
                                </div>
                                <!-- Show total count -->
                                <span class="text-sm text-gray-600" th:text="${selectedDish.reactions}">0</span>
                            </div>
                            <!-- Mobile comments - always right aligned -->
                            <button id="mobile-comments-btn" type="button" class="ml-auto flex items-center space-x-2 text-gray-600 focus:outline-none group">
                                <i class="fa-regular fa-comment text-xl text-blue-500"></i>
                                <span class="font-medium text-base" th:text="${selectedDish != null ? selectedDish.commentsCount : 0}">0</span>
                                <span class="text-sm">Comments</span>
                            </button>
                        </div>
                        <!-- Main reaction button on separate line - SECOND -->
                        <div class="flex items-center">
                            <!-- Mobile Reaction System -->
                            <div class="relative">
                                <!-- Main reaction button with emoji and text -->
                                <button id="mobile-reaction-btn" type="button" class="flex items-center space-x-2 text-gray-600 hover:text-gray-800 focus:outline-none transition-colors duration-200">
                                    <div class="relative flex items-center">
                                        <span id="mobile-reaction-icon" class="text-xl transition-all duration-200" 
                                              data-reaction-type="NONE"
                                              th:data-reaction-type="${selectedDish != null && selectedDish.userReactionType != null ? selectedDish.userReactionType : 'NONE'}">
                                            <i th:if="${selectedDish == null || selectedDish.userReactionType == null}" class="fa-regular fa-smile text-gray-400"></i>
                                            <span th:if="${selectedDish != null && selectedDish.userReactionType == 'DELICIOUS'}">üòã</span>
                                            <span th:if="${selectedDish != null && selectedDish.userReactionType == 'AVERAGE'}">üòê</span>
                                            <span th:if="${selectedDish != null && selectedDish.userReactionType == 'BAD'}">üòû</span>
                                        </span>
                                        <span id="mobile-reaction-text" class="font-medium text-base ml-1"
                                              th:text="${selectedDish != null && selectedDish.userReactionType == 'DELICIOUS' ? 'Delicious' : (selectedDish != null && selectedDish.userReactionType == 'AVERAGE' ? 'Average' : (selectedDish != null && selectedDish.userReactionType == 'BAD' ? 'Bad' : 'React'))}"
                                              th:classappend="${selectedDish != null && selectedDish.userReactionType == 'DELICIOUS' ? 'text-green-600' : (selectedDish != null && selectedDish.userReactionType == 'AVERAGE' ? 'text-yellow-600' : (selectedDish != null && selectedDish.userReactionType == 'BAD' ? 'text-red-600' : 'text-gray-400'))}">
                                            React
                                        </span>
                                    </div>
                                </button>
                                <!-- Facebook-style Hover Menu -->
                                <div id="mobile-reaction-menu" class="absolute bottom-full left-0 mb-3 bg-white border border-gray-200 rounded-full shadow-xl p-2 hidden z-50 transform scale-100 transition-all duration-200">
                                    <div class="flex space-x-1">
                                        <button class="reaction-option p-2 hover:scale-125 transition-all duration-200 rounded-full hover:bg-gray-50" data-reaction="DELICIOUS" data-emoji="üòã" data-text="Delicious" title="Delicious">
                                            <span class="text-2xl filter drop-shadow-sm">üòã</span>
                                        </button>
                                        <button class="reaction-option p-2 hover:scale-125 transition-all duration-200 rounded-full hover:bg-gray-50" data-reaction="AVERAGE" data-emoji="üòê" data-text="Average" title="Average">
                                            <span class="text-2xl filter drop-shadow-sm">üòê</span>
                                        </button>
                                        <button class="reaction-option p-2 hover:scale-125 transition-all duration-200 rounded-full hover:bg-gray-50" data-reaction="BAD" data-emoji="üòû" data-text="Bad" title="Bad">
                                            <span class="text-2xl filter drop-shadow-sm">üòû</span>
                                        </button>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
            
            <div th:if="${selectedDish == null}" class="text-center text-gray-500 py-10">
                No dishes available for this date.
            </div>
        </div>
    </main>

    <!-- Mobile Comments Modal -->
    <div id="mobile-comments-modal" class="hidden md:hidden fixed inset-0 bg-black bg-opacity-50 z-50 flex flex-col">
        <div class="flex-1 flex flex-col bg-white">
            <!-- Modal Header -->
            <div class="flex items-center justify-between p-4 border-b border-gray-200 bg-white">
                <h3 class="text-lg font-semibold text-gray-800">Comments</h3>
                <button id="close-comments-modal" class="text-gray-500 hover:text-gray-700">
                    <i class="fa-solid fa-times text-xl"></i>
                </button>
            </div>
            
            <!-- Comments List -->
            <div id="mobile-comments-list" class="flex-1 overflow-y-auto p-4 space-y-4">
                <!-- Comments will be loaded here by JS -->
            </div>
            
            <!-- Comment Input -->
            <div th:if="${!selectedDate.isAfter(T(java.time.LocalDate).now())}" class="border-t border-gray-200 p-4 bg-white">
                <!-- Error message -->
                <div th:if="${error}" class="mb-3 p-2 bg-red-100 border border-red-300 text-red-700 rounded text-sm">
                    <span th:text="${error}">Comment cannot be empty.</span>
                </div>
                
                <form id="mobile-comment-form" th:action="@{/weekly-feedback/feedback}" method="post" class="flex items-center space-x-3">
                    <input type="hidden" name="date" th:value="${selectedDate}">
                    <input type="hidden" name="dishId" th:value="${selectedDish != null ? selectedDish.id : ''}">
                    <div class="flex-1 relative">
                        <input type="text" name="comment" placeholder="Write a comment..." class="w-full px-4 py-3 pr-12 text-sm border border-gray-300 rounded-full focus:outline-none focus:ring-2 focus:ring-primary/50 focus:border-primary transition">
                    </div>
                    <button type="submit" class="text-primary">
                        <i class="fa-regular fa-paper-plane text-lg"></i>
                    </button>
                </form>
            </div>
        </div>
    </div>
    <div th:replace="fragments/layout :: footer"></div>
    <script th:inline="javascript">
    /*<![CDATA[*/
    let currentPage = 0;
    const pageSize = 20;
    let currentDishId = /*[[${selectedDish != null ? selectedDish.id : 0}]]*/ 0;
    
    let currentDate = /*[[${selectedDate}]]*/ '';

    async function loadComments(reset = false) {
        const commentsList = document.getElementById('comments-list');
        if (reset) commentsList.innerHTML = '';
        if (!currentDishId || !currentDate) return;
        // Remove quotes if present
        //let dateParam = currentDate.replace(/^['"]|['"]$/g, '');
        const res = await fetch(`/weekly-feedback/comments?dishId=${currentDishId}&page=${currentPage}&size=${pageSize}`);
        const data = await res.json();
        if (!data.comments || (data.comments.length === 0 && currentPage === 0)) {
            commentsList.innerHTML = '<div class="text-gray-500 text-sm">No comments yet.</div>';
        } else {
            data.comments.forEach(comment => {
                commentsList.innerHTML += `
                    <div class="flex items-start space-x-3">
                        <img src="${comment.avatarUrl}" alt="${comment.userName}" class="w-10 h-10 rounded-full object-cover border-2 border-white shadow referrerpolicy="no-referrer"">
                        <div>
                            <p class="font-semibold text-gray-800 text-sm">${comment.userName}</p>
                            <p class="text-gray-600 text-sm">${comment.text}</p>
                        </div>
                    </div>
                `;
            });
        }
        // Show/hide Load More button
        const loadMoreBtn = document.getElementById('load-more-comments-btn');
        if (data.hasMore) {
            loadMoreBtn.classList.remove('hidden');
        } else {
            loadMoreBtn.classList.add('hidden');
        }
    }

    async function loadMobileComments(reset = false) {
        const mobileCommentsList = document.getElementById('mobile-comments-list');
        if (!mobileCommentsList) return;
        
        if (reset) {
            mobileCommentsList.innerHTML = '';
            currentPage = 0;
        }
        
        if (!currentDishId || !currentDate) {
            mobileCommentsList.innerHTML = '<div class="text-gray-500 text-sm text-center py-8">No dish selected.</div>';
            return;
        }
        
        try {
            // Show loading state
            if (reset) {
                mobileCommentsList.innerHTML = '<div class="text-gray-500 text-sm text-center py-8">Loading comments...</div>';
            }
            
            // Get the comment count from the dish data
            const commentCountElement = document.querySelector('#mobile-comments-btn span');
            const commentCount = commentCountElement ? parseInt(commentCountElement.textContent, 10) : 0;
            
            // Load all comments for mobile view using the actual comment count
            const res = await fetch(`/weekly-feedback/comments?dishId=${currentDishId}&page=0&size=${commentCount}`);
            
            if (!res.ok) {
                throw new Error('Failed to load comments');
            }
            
            const data = await res.json();
            
            if (reset) {
                mobileCommentsList.innerHTML = '';
            }
            
            if (!data.comments || (data.comments.length === 0 && currentPage === 0)) {
                mobileCommentsList.innerHTML = '<div class="text-gray-500 text-sm text-center py-8">No comments yet. Be the first to comment!</div>';
            } else {
                data.comments.forEach(comment => {
                    mobileCommentsList.innerHTML += `
                        <div class="flex items-start space-x-3">
                            <img src="${comment.avatarUrl}" alt="${comment.userName}" class="w-10 h-10 rounded-full object-cover border-2 border-white shadow flex-shrink-0">
                            <div class="flex-1">
                                <p class="font-semibold text-gray-800 text-sm">${comment.userName}</p>
                                <p class="text-gray-600 text-sm">${comment.text}</p>
                            </div>
                        </div>
                    `;
                });
                
                // Scroll to bottom to show the latest comment
                if (reset) {
                    setTimeout(() => {
                        mobileCommentsList.scrollTop = mobileCommentsList.scrollHeight;
                    }, 100);
                }
            }
        } catch (error) {
            console.error('Error loading mobile comments:', error);
            mobileCommentsList.innerHTML = '<div class="text-red-500 text-sm text-center py-8">Failed to load comments. Please try again.</div>';
        }
    }

    document.addEventListener('DOMContentLoaded', function() {
        // Scroll active dish tab into view on page load
        function scrollActiveTabIntoView() {
            const mobileDishTabs = document.getElementById('mobile-dish-tabs');
            const activeTab = mobileDishTabs?.querySelector('.active-tab');
            
            if (mobileDishTabs && activeTab) {
                // Calculate the scroll position to center the active tab
                const containerWidth = mobileDishTabs.offsetWidth;
                const tabLeft = activeTab.offsetLeft;
                const tabWidth = activeTab.offsetWidth;
                const scrollLeft = tabLeft - (containerWidth / 2) + (tabWidth / 2);
                
                // Instant scroll to the active tab (no animation)
                mobileDishTabs.scrollLeft = Math.max(0, scrollLeft);
            }
        }

        // Mobile menu functionality
        const mobileMenuButton = document.getElementById('mobile-menu-button');
        const mobileMenu = document.getElementById('mobile-menu');
        
        if (mobileMenuButton && mobileMenu) {
            mobileMenuButton.addEventListener('click', function(e) {
                e.preventDefault();
                e.stopPropagation();
                
                const isHidden = mobileMenu.classList.contains('hidden');
                
                if (isHidden) {
                    mobileMenu.classList.remove('hidden');
                    mobileMenu.classList.add('block');
                    mobileMenuButton.innerHTML = '<i class="fa-solid fa-times text-xl"></i>';
                } else {
                    mobileMenu.classList.add('hidden');
                    mobileMenu.classList.remove('block');
                    mobileMenuButton.innerHTML = '<i class="fa-solid fa-bars text-xl"></i>';
                }
            });
            
            // Close menu when clicking outside
            document.addEventListener('click', function(event) {
                const isClickInsideMenu = mobileMenu.contains(event.target);
                const isClickOnButton = mobileMenuButton.contains(event.target);
                
                if (!isClickInsideMenu && !isClickOnButton && !mobileMenu.classList.contains('hidden')) {
                    mobileMenu.classList.add('hidden');
                    mobileMenu.classList.remove('block');
                    mobileMenuButton.innerHTML = '<i class="fa-solid fa-bars text-xl"></i>';
                }
            });
            
            // Prevent menu from closing when clicking inside menu
            mobileMenu.addEventListener('click', function(e) {
                e.stopPropagation();
            });
        }

        // Mobile calendar modal functionality
        const mobileCalendarToggle = document.getElementById('mobile-calendar-toggle');
        const mobileCalendarModal = document.getElementById('mobile-calendar-modal');
        const closeCalendarModal = document.getElementById('close-calendar-modal');
        
        if (mobileCalendarToggle && mobileCalendarModal) {
            mobileCalendarToggle.addEventListener('click', function() {
                mobileCalendarModal.classList.remove('hidden');
            });
            
            closeCalendarModal.addEventListener('click', function() {
                mobileCalendarModal.classList.add('hidden');
            });
            
            // Close modal when clicking outside
            mobileCalendarModal.addEventListener('click', function(e) {
                if (e.target === mobileCalendarModal) {
                    mobileCalendarModal.classList.add('hidden');
                }
            });
        }

        // Desktop comments functionality
        if (document.getElementById('comments-list') && currentDishId && currentDate) {
            currentPage = 0;
            loadComments(true);
        }
        
        // Desktop reaction functionality
        const reactionBtn = document.getElementById('reaction-btn');
        const reactionMenu = document.getElementById('reaction-menu');
        const reactionDisplay = document.getElementById('reaction-count-display'); // Updated selector
        const reactionText = document.getElementById('reaction-text');
        const reactionIcon = document.getElementById('reaction-icon'); // New element

        // Initialize reaction state from server data
        if (reactionDisplay) {
            // Initialize the reaction count display
            const reactionCounts = /*[[${selectedDish != null ? selectedDish.reactionCounts : null}]]*/ {};
            const totalReactions = /*[[${selectedDish != null ? selectedDish.reactions : 0}]]*/ 0;
            
            // Update the reaction count display based on server data
            updateReactionDisplay(reactionCounts, null);
            
            // Initialize the main reaction button
            const userReactionType = /*[[${selectedDish != null ? selectedDish.userReactionType : null}]]*/ null;
            updateReactionIcon(userReactionType);
            
            // Initialize the text
            const currentText = reactionText.textContent;
            reactionText.textContent = currentText;
        }

        if (reactionBtn) {
            let menuTimeout;
            
            // Show menu on hover
            reactionBtn.addEventListener('mouseenter', function() {
                clearTimeout(menuTimeout);
                reactionMenu.classList.remove('hidden');
            });

            // Hide menu with delay when leaving the button
            reactionBtn.addEventListener('mouseleave', function() {
                menuTimeout = setTimeout(() => {
                    reactionMenu.classList.add('hidden');
                }, 100);
            });

            // Keep menu visible when hovering over menu
            reactionMenu.addEventListener('mouseenter', function() {
                clearTimeout(menuTimeout);
            });

            // Hide menu when leaving the menu
            reactionMenu.addEventListener('mouseleave', function() {
                reactionMenu.classList.add('hidden');
            });

            // Handle reaction option clicks directly
            reactionMenu.addEventListener('click', function(e) {
                const reactionOption = e.target.closest('.reaction-option');
                if (!reactionOption) return;

                // Check if user is authenticated first
                const isAuthenticated = /*[[${isAuthenticated}]]*/ false;
                if (!isAuthenticated) {
                    // Save current URL in a cookie and redirect to login
                    var currentUrl = window.location.pathname + window.location.search + window.location.hash;
                    document.cookie = "redirectAfterLogin=" + encodeURIComponent(currentUrl) + "; path=/";
                    window.location.href = '/login';
                    return;
                }

                const reactionType = reactionOption.dataset.reaction;
                const emoji = reactionOption.dataset.emoji;
                const text = reactionOption.dataset.text;
                const currentReactionType = reactionIcon.dataset.reactionType;

                // Send request with the actual reaction type
                fetch('/api/reactions', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ dishId: currentDishId, reactionType: reactionType })
                })
                .then(res => {
                    if (res.redirected) {
                        // Handle redirect to login
                        window.location.href = res.url;
                        return;
                    }
                    if (!res.ok) {
                        return res.json().then(errorData => {
                            throw new Error(errorData.error || `HTTP ${res.status}: ${res.statusText}`);
                        }).catch(() => {
                            throw new Error(`HTTP ${res.status}: ${res.statusText}`);
                        });
                    }
                    return res.json();
                })
                .then(data => {
                    if (data) { // Only process if we got data (not redirected)
                        // Update reaction count display with server response
                        updateReactionDisplay(data.reactionCounts, data.userReactionType);
                        
                        // Update main reaction button icon
                        updateReactionIcon(data.userReactionType);
                        
                        // Update text based on user reaction
                        if (data.userReactionType) {
                            reactionText.textContent = getReactionText(data.userReactionType);
                            reactionText.className = 'font-medium text-sm ml-1 ' + getReactionColorClass(data.userReactionType);
                        } else {
                            reactionText.textContent = 'React';
                            reactionText.className = 'font-medium text-sm ml-1 text-gray-400';
                        }
                    }
                })
                .catch(error => {
                    console.error('Error submitting reaction:', error);
                    alert('Failed to submit reaction. Please try again. Error: ' + error.message);
                });

                // Hide menu after selection
                reactionMenu.classList.add('hidden');
            });
        }

        // Helper functions for reaction display
        function updateReactionDisplay(reactionCounts, userReactionType) {
            if (!reactionDisplay) return;
            
            // Calculate total reactions
            const totalReactions = reactionCounts ? 
                (reactionCounts.DELICIOUS || 0) + (reactionCounts.AVERAGE || 0) + (reactionCounts.BAD || 0) : 0;
            
            if (totalReactions > 0) {
                // Show the reaction count display
                reactionDisplay.style.display = 'flex';
                
                // Clear existing display
                reactionDisplay.innerHTML = '';
                
                // Create emoji container
                const emojiContainer = document.createElement('div');
                emojiContainer.className = 'flex items-center';
                
                // Add reaction emojis side by side
                if (reactionCounts) {
                    if (reactionCounts.DELICIOUS > 0) {
                        const deliciousSpan = document.createElement('span');
                        deliciousSpan.textContent = 'üòã';
                        emojiContainer.appendChild(deliciousSpan);
                    }
                    
                    if (reactionCounts.AVERAGE > 0) {
                        const averageSpan = document.createElement('span');
                        averageSpan.textContent = 'üòê';
                        emojiContainer.appendChild(averageSpan);
                    }
                    
                    if (reactionCounts.BAD > 0) {
                        const badSpan = document.createElement('span');
                        badSpan.textContent = 'üòû';
                        emojiContainer.appendChild(badSpan);
                    }
                }
                
                // Add emoji container
                reactionDisplay.appendChild(emojiContainer);
                
                // Add total count
                const countSpan = document.createElement('span');
                countSpan.className = 'text-xs text-gray-600';
                countSpan.textContent = totalReactions;
                reactionDisplay.appendChild(countSpan);
            } else {
                // Hide the reaction count display when no reactions
                reactionDisplay.style.display = 'none';
            }
        }

        function updateReactionIcon(userReactionType) {
            if (!reactionIcon) return;
            
            // Update the main reaction button icon
            if (userReactionType) {
                const emojiMap = {
                    'DELICIOUS': 'üòã',
                    'AVERAGE': 'üòê',
                    'BAD': 'üòû'
                };
                reactionIcon.innerHTML = emojiMap[userReactionType] || 'üòã';
                reactionIcon.dataset.reactionType = userReactionType;
            } else {
                reactionIcon.innerHTML = '<i class="fa-regular fa-smile text-gray-400"></i>';
                reactionIcon.dataset.reactionType = 'NONE';
            }
        }

        function getReactionText(reactionType) {
            const textMap = {
                'DELICIOUS': 'Delicious',
                'AVERAGE': 'Average',
                'BAD': 'Bad'
            };
            return textMap[reactionType] || 'React';
        }

        function getReactionColorClass(reactionType) {
            const colorMap = {
                'DELICIOUS': 'text-green-600',
                'AVERAGE': 'text-yellow-600',
                'BAD': 'text-red-600'
            };
            return colorMap[reactionType] || 'text-gray-600';
        }

        // Mobile reaction functionality
        const mobileReactionBtn = document.getElementById('mobile-reaction-btn');
        const mobileReactionMenu = document.getElementById('mobile-reaction-menu');
        const mobileReactionText = document.getElementById('mobile-reaction-text');
        const mobileReactionIcon = document.getElementById('mobile-reaction-icon');
        const mobileReactionDisplay = document.getElementById('mobile-reaction-count-display');

        // Initialize mobile reaction state from server data
        if (mobileReactionIcon) {
            // Initialize the main reaction button
            const mobileUserReactionType = /*[[${selectedDish != null ? selectedDish.userReactionType : null}]]*/ null;
            updateMobileReactionIcon(mobileUserReactionType);
            
            // Initialize the text
            const currentText = mobileReactionText.textContent;
            mobileReactionText.textContent = currentText;
        }

        if (mobileReactionBtn) {
            let mobileMenuTimeout;
            
            // Show menu on hover
            mobileReactionBtn.addEventListener('mouseenter', function() {
                clearTimeout(mobileMenuTimeout);
                mobileReactionMenu.classList.remove('hidden');
            });

            // Hide menu with delay when leaving the button
            mobileReactionBtn.addEventListener('mouseleave', function() {
                mobileMenuTimeout = setTimeout(() => {
                    mobileReactionMenu.classList.add('hidden');
                }, 100);
            });

            // Keep menu visible when hovering over menu
            mobileReactionMenu.addEventListener('mouseenter', function() {
                clearTimeout(mobileMenuTimeout);
            });

            // Hide menu when leaving the menu
            mobileReactionMenu.addEventListener('mouseleave', function() {
                mobileReactionMenu.classList.add('hidden');
            });

            // Handle reaction option clicks directly
            mobileReactionMenu.addEventListener('click', function(e) {
                const reactionOption = e.target.closest('.reaction-option');
                if (!reactionOption) return;

                // Check if user is authenticated first
                const isAuthenticated = /*[[${isAuthenticated}]]*/ false;
                if (!isAuthenticated) {
                    // Save current URL in a cookie and redirect to login
                    var currentUrl = window.location.pathname + window.location.search + window.location.hash;
                    document.cookie = "redirectAfterLogin=" + encodeURIComponent(currentUrl) + "; path=/";
                    window.location.href = '/login';
                    return;
                }

                const reactionType = reactionOption.dataset.reaction;
                const emoji = reactionOption.dataset.emoji;
                const text = reactionOption.dataset.text;
                const currentReactionType = mobileReactionIcon.dataset.reactionType;

                // Send request with the actual reaction type
                fetch('/api/reactions', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ dishId: currentDishId, reactionType: reactionType })
                })
                .then(res => {
                    if (res.redirected) {
                        // Handle redirect to login
                        window.location.href = res.url;
                        return;
                    }
                    if (!res.ok) {
                        return res.json().then(errorData => {
                            throw new Error(errorData.error || `HTTP ${res.status}: ${res.statusText}`);
                        }).catch(() => {
                            throw new Error(`HTTP ${res.status}: ${res.statusText}`);
                        });
                    }
                    return res.json();
                })
                .then(data => {
                    if (data) { // Only process if we got data (not redirected)
                        // Update reaction count display with server response
                        updateMobileReactionDisplay(data.reactionCounts, data.userReactionType);
                        
                        // Update main reaction button icon
                        updateMobileReactionIcon(data.userReactionType);
                        
                        // Update text based on user reaction
                        if (data.userReactionType) {
                            mobileReactionText.textContent = getReactionText(data.userReactionType);
                            mobileReactionText.className = 'font-medium text-base ml-1 ' + getReactionColorClass(data.userReactionType);
                        } else {
                            mobileReactionText.textContent = 'React';
                            mobileReactionText.className = 'font-medium text-base ml-1 text-gray-400';
                        }
                    }
                })
                .catch(error => {
                    console.error('Error submitting reaction:', error);
                    alert('Failed to submit reaction. Please try again. Error: ' + error.message);
                });

                // Hide menu after selection
                mobileReactionMenu.classList.add('hidden');
            });
        }

        // Helper function for mobile reaction display
        function updateMobileReactionDisplay(reactionCounts, userReactionType) {
            if (!mobileReactionDisplay) return;
            
            // Clear existing display
            mobileReactionDisplay.innerHTML = '';
            
            // Create emoji container
            const emojiContainer = document.createElement('div');
            emojiContainer.className = 'flex items-center space-x-1';
            
            // Add reaction emojis side by side
            if (reactionCounts) {
                if (reactionCounts.DELICIOUS > 0) {
                    const deliciousSpan = document.createElement('span');
                    deliciousSpan.textContent = 'üòã';
                    emojiContainer.appendChild(deliciousSpan);
                }
                
                if (reactionCounts.AVERAGE > 0) {
                    const averageSpan = document.createElement('span');
                    averageSpan.textContent = 'üòê';
                    emojiContainer.appendChild(averageSpan);
                }
                
                if (reactionCounts.BAD > 0) {
                    const badSpan = document.createElement('span');
                    badSpan.textContent = 'üòû';
                    emojiContainer.appendChild(badSpan);
                }
            }
            
            // Calculate total reactions
            const totalReactions = reactionCounts ? 
                (reactionCounts.DELICIOUS || 0) + (reactionCounts.AVERAGE || 0) + (reactionCounts.BAD || 0) : 0;
            
            if (totalReactions > 0) {
                // Add emoji container
                mobileReactionDisplay.appendChild(emojiContainer);
                
                // Add total count
                const countSpan = document.createElement('span');
                countSpan.className = 'text-sm text-gray-600';
                countSpan.textContent = totalReactions;
                mobileReactionDisplay.appendChild(countSpan);
            } else {
                // Show default state if no reactions
                const defaultSpan = document.createElement('span');
                defaultSpan.className = 'text-gray-400';
                defaultSpan.innerHTML = '<i class="fa-regular fa-smile"></i>';
                mobileReactionDisplay.appendChild(defaultSpan);
            }
        }

        function updateMobileReactionIcon(userReactionType) {
            if (!mobileReactionIcon) return;
            
            // Update the main reaction button icon
            if (userReactionType) {
                const emojiMap = {
                    'DELICIOUS': 'üòã',
                    'AVERAGE': 'üòê',
                    'BAD': 'üòû'
                };
                mobileReactionIcon.innerHTML = emojiMap[userReactionType] || 'üòã';
                mobileReactionIcon.dataset.reactionType = userReactionType;
            } else {
                mobileReactionIcon.innerHTML = '<i class="fa-regular fa-smile text-gray-400"></i>';
                mobileReactionIcon.dataset.reactionType = 'NONE';
            }
        }

        // Mobile comments modal functionality
        const mobileCommentsBtn = document.getElementById('mobile-comments-btn');
        const mobileCommentsModal = document.getElementById('mobile-comments-modal');
        const closeCommentsModal = document.getElementById('close-comments-modal');
        const mobileCommentsList = document.getElementById('mobile-comments-list');
        const mobileCommentForm = document.getElementById('mobile-comment-form');

        if (mobileCommentsBtn && mobileCommentsModal && mobileCommentsList && mobileCommentForm) {
            mobileCommentsBtn.addEventListener('click', function() {
                mobileCommentsModal.classList.remove('hidden');
                // Reset page and load comments for the modal
                currentPage = 0;
                loadMobileComments(true);
            });

            closeCommentsModal.addEventListener('click', function() {
                mobileCommentsModal.classList.add('hidden');
            });

            // Close modal when clicking outside
            mobileCommentsModal.addEventListener('click', function(e) {
                if (e.target === mobileCommentsModal) {
                    mobileCommentsModal.classList.add('hidden');
                }
            });

            // Handle form submission
            mobileCommentForm.addEventListener('submit', async function(e) {
                e.preventDefault();
                
                // Check if user is authenticated
                const isAuthenticated = /*[[${isAuthenticated}]]*/ false;
                if (!isAuthenticated) {
                    // Save current URL in a cookie and redirect to login
                    var currentUrl = window.location.pathname + window.location.search + window.location.hash;
                    document.cookie = "redirectAfterLogin=" + encodeURIComponent(currentUrl) + "; path=/";
                    window.location.href = '/login';
                    return false;
                }
                
                const commentInput = this.querySelector('input[name="comment"]');
                const commentText = commentInput.value;
                
                if (!commentText.trim()) {
                    alert('Comment cannot be empty.');
                    return;
                }
                
                const formData = new FormData(this);
                try {
                    const res = await fetch('/weekly-feedback/feedback', {
                        method: 'POST',
                        body: formData
                    });
                    
                    if (res.ok) {
                        // Clear the input
                        commentInput.value = '';
                        
                        // Update comment count instantly
                        const commentCountElement = document.querySelector('#mobile-comments-btn span');
                        if (commentCountElement) {
                            const currentCount = parseInt(commentCountElement.textContent, 10);
                            commentCountElement.textContent = currentCount + 1;
                        }
                        
                        // Reload comments to show the new comment
                        currentPage = 0;
                        loadMobileComments(true);
                        
                    } else {
                        const errorData = await res.json();
                        alert(errorData.message || 'Failed to submit comment.');
                    }
                } catch (error) {
                    console.error('Error submitting comment:', error);
                    alert('Failed to submit comment. Please try again.');
                }
            });
        }

        // --- Desktop comment form guest login redirect ---
        const feedbackForm = document.querySelector('#feedback-form form');
        if (feedbackForm) {
            feedbackForm.addEventListener('submit', function(e) {
                const isAuthenticated = /*[[${isAuthenticated}]]*/ false;
                if (!isAuthenticated) {
                    e.preventDefault();
                    var currentUrl = window.location.pathname + window.location.search + window.location.hash;
                    document.cookie = "redirectAfterLogin=" + encodeURIComponent(currentUrl) + "; path=/";
                    window.location.href = '/login';
                    return false;
                }
            });
        }

        // --- Desktop comment input guest login redirect on keyup ---
        const feedbackFormInput = document.querySelector('#feedback-form input[name="comment"]');
        if (feedbackFormInput) {
            feedbackFormInput.addEventListener('keyup', function(e) {
                const isAuthenticated = /*[[${isAuthenticated}]]*/ false;
                if (!isAuthenticated) {
                    var currentUrl = window.location.pathname + window.location.search + window.location.hash;
                    document.cookie = "redirectAfterLogin=" + encodeURIComponent(currentUrl) + "; path=/";
                    window.location.href = '/login';
                }
            });
        }

        // Scroll active tab into view after page load and after navigation
        scrollActiveTabIntoView();
        
        // Also scroll active tab into view when window is resized (orientation change)
        window.addEventListener('resize', function() {
            setTimeout(scrollActiveTabIntoView, 100); // Small delay to ensure DOM is updated
        });
    });

    document.getElementById('load-more-comments-btn').onclick = function() {
        currentPage++;
        loadComments(false);
    };
    /*]]>*/
    </script>
    <style>
        /* Custom scrollbar for comments list */
        #comments-list {
            scrollbar-width: thin;
            scrollbar-color: #3B82F6 #F3F4F6;
        }
        #comments-list::-webkit-scrollbar {
            width: 8px;
            background: #F3F4F6;
            border-radius: 8px;
        }
        #comments-list::-webkit-scrollbar-thumb {
            background: #3B82F6;
            border-radius: 8px;
        }
        
        /* Hide scrollbar for mobile dish tabs */
        .scrollbar-hide {
            -ms-overflow-style: none;  /* Internet Explorer 10+ */
            scrollbar-width: none;  /* Firefox */
        }
        .scrollbar-hide::-webkit-scrollbar {
            display: none;  /* Safari and Chrome */
        }
        
        /* Ensure smooth scrolling is disabled for mobile dish tabs */
        #mobile-dish-tabs {
            scroll-behavior: auto;
        }
        
        /* Facebook-style reaction system */
        .reaction-option {
            position: relative;
            overflow: hidden;
        }
        
        .reaction-option:hover {
            transform: scale(1.25);
            z-index: 10;
        }
        
        .reaction-option span {
            display: inline-block;
            transition: all 0.2s ease;
        }
        
        .reaction-option:hover span {
            animation: bounce 0.3s ease;
        }
        
        @keyframes bounce {
            0%, 100% { transform: translateY(0); }
            50% { transform: translateY(-2px); }
        }
        
        /* Reaction menu positioning and visibility */
        #reaction-menu, #mobile-reaction-menu {
            opacity: 0;
            transform: scale(0.8) translateY(10px);
            transition: all 0.2s ease;
            pointer-events: none;
        }
        
        #reaction-menu:not(.hidden), #mobile-reaction-menu:not(.hidden) {
            opacity: 1;
            transform: scale(1) translateY(0);
            pointer-events: auto;
        }
        
        /* Reaction icon animations */
        #reaction-icon, #mobile-reaction-icon {
            transition: all 0.2s ease;
        }
        
        #reaction-icon:hover, #mobile-reaction-icon:hover {
            transform: scale(1.1);
        }
        
        /* Mobile responsive adjustments */
        @media (max-width: 768px) {
            #main-content {
                padding-top: 0; /* Remove extra padding since we have mt-32 */
            }
            
            /* Ensure modal takes full height */
            #mobile-comments-modal {
                height: 100vh;
            }
            
            /* Mobile comments list styling */
            #mobile-comments-list {
                scrollbar-width: thin;
                scrollbar-color: #3B82F6 #F3F4F6;
            }
            #mobile-comments-list::-webkit-scrollbar {
                width: 4px;
                background: #F3F4F6;
            }
            #mobile-comments-list::-webkit-scrollbar-thumb {
                background: #3B82F6;
                border-radius: 4px;
            }
        }
    </style>
</body>
</html> 