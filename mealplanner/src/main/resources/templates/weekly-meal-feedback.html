<!DOCTYPE html>
<html xmlns:th="http://www.thymeleaf.org">
<head th:replace="~{fragments/layout :: head}">
    <style>
        /* Responsive text adjustments */
        .break-words {
            word-wrap: break-word;
            overflow-wrap: break-word;
        }
        
        .break-all {
            word-break: break-all;
            overflow-wrap: break-word;
        }
        
        /* Ensure text doesn't overflow on small screens */
        @media (max-width: 640px) {
            h1, h2, h3, h4 {
                word-break: break-word;
                hyphens: auto;
            }
        }
        
        /* Improve line height for better readability */
        .leading-tight {
            line-height: 1.1;
        }
        
        .leading-relaxed {
            line-height: 1.6;
        }
    </style>
    <!-- Lottie Animation Library -->
    <script src="https://unpkg.com/lottie-web@5.12.2/build/player/lottie.min.js"></script>
</head>
<body class="bg-white flex flex-col min-h-screen">
    <!-- Top Navigation Bar -->
    <header class="bg-white shadow-sm fixed top-0 left-0 w-full z-50">
        <div class="container mx-auto px-5 py-4">
            <div class="flex items-center justify-between">
                <div class="flex items-center space-x-2">
                    <a th:href="@{/}" class="cursor-pointer">
                        <img src="/images/foodsi-logo-01.svg" alt="Foodsi logo" class="w-40 h-16">
                    </a>
                </div>
                <div class="flex items-center space-x-6">
                    <!-- Desktop Navigation -->
                    <nav class="hidden md:flex items-center space-x-6">
                        <a th:href="@{/}" class="hover:text-orange-600 cursor-pointer">Today's Menu</a>
                        <a th:href="@{/weekly-feedback}" class="text-orange-600 font-semibold border-b-2 border-orange-600 pb-1 cursor-pointer">Weekly Menu</a>
                    </nav>
                    <!-- Desktop User Profile -->
                    <div th:replace="fragments/layout :: topnav-user"></div>
                    
                    <!-- Mobile Hamburger Menu Button -->
                    <button id="mobile-menu-button" class="block md:hidden flex items-center p-2 rounded-md text-gray-600 hover:text-primary hover:bg-gray-100 focus:outline-none focus:ring-2 focus:ring-inset focus:ring-primary">
                        <i class="fa-solid fa-bars text-xl"></i>
                    </button>
                </div>
            </div>
            
            <!-- Mobile Date Selector -->
            <div class="md:hidden mt-4 pb-4">
                <div class="flex items-center justify-between pt-4">
                    <div class="flex items-center space-x-3">
                        <i class="text-orange-600 text-lg fa-solid fa-calendar"></i>
                        <span class="text-lg font-semibold text-gray-800" th:text="${#temporals.format(selectedDate, 'dd MMMM, yyyy')}">18 July, 2025</span>
                    </div>
                    <button id="mobile-calendar-toggle" class="flex items-center space-x-2 text-orange-600">
                        <span class="text-sm font-medium">Change Date</span>
                        <i class="fa-solid fa-chevron-down text-xs"></i>
                    </button>
                </div>
            </div>
        </div>
    </header>

    <!-- Mobile Navigation Menu - Positioned outside header -->
    <div id="mobile-menu" class="hidden md:hidden fixed top-20 right-4 z-50">
        <div class="bg-white rounded-lg shadow-lg min-w-[200px]">
            <div class="flex flex-col space-y-3 pt-4 px-4 pb-4">
                <a th:href="@{/}" class="text-gray-600 hover:text-primary cursor-pointer py-2 w-fit">Today's Menu</a>
                <a th:href="@{/weekly-feedback}" class="text-primary font-semibold border-b-2 border-primary pb-1 cursor-pointer py-2 w-fit">Weekly Menu</a>
                <div class="border-t border-gray-200 pt-3">
                    <!-- Show login for anonymous users -->
                    <a th:if="${!isAuthenticated}" th:href="@{/login}" class="hover:text-orange-600 cursor-pointer w-fit text-left py-2 flex items-center">
                        Sign In
                    </a>
                    <!-- Show logout for authenticated users -->
                    <form th:if="${isAuthenticated}" th:action="@{/logout}" method="post" class="inline">
                        <button type="submit" class="text-gray-600 hover:text-primary cursor-pointer w-fit text-left py-2 flex items-center">
                            <i class="fa-solid fa-sign-out-alt mr-2"></i>
                            Sign Out
                        </button>
                    </form>
                </div>
            </div>
        </div>
    </div>

    <!-- Mobile Calendar Modal -->
    <div id="mobile-calendar-modal" class="hidden md:hidden fixed inset-0 bg-black bg-opacity-50 z-50 flex items-center justify-center p-4">
        <div class="bg-white rounded-lg shadow-xl w-full max-w-sm">
            <div class="flex items-center justify-between p-4 border-b border-gray-200">
                <h3 class="text-lg font-semibold text-gray-800">Select Date</h3>
                <button id="close-calendar-modal" class="text-gray-500 hover:text-gray-700">
                    <i class="fa-solid fa-times text-xl"></i>
                </button>
            </div>
            <div class="p-4">
                <div class="flex items-center justify-between mb-4">
                    <h4 class="text-base font-semibold text-gray-800" th:text="${calendarMonthYear}">December 2023</h4>
                    <div class="flex space-x-2">
                        <a th:href="@{/weekly-feedback(date=${prevMonthDate})}" class="p-1 hover:bg-gray-200 rounded transition-colors">
                            <i class="text-gray-600 text-sm fas fa-chevron-left"></i>
                        </a>
                        <a th:href="@{/weekly-feedback(date=${nextMonthDate})}" class="p-1 hover:bg-gray-200 rounded transition-colors">
                            <i class="text-gray-600 text-sm fas fa-chevron-right"></i>
                        </a>
                    </div>
                </div>
                <div class="grid grid-cols-7 gap-1 text-center text-sm">
                    <!-- Days of week -->
                    <div class="p-2 text-gray-500 font-medium text-xs">S</div>
                    <div class="p-2 text-gray-500 font-medium text-xs">M</div>
                    <div class="p-2 text-gray-500 font-medium text-xs">T</div>
                    <div class="p-2 text-gray-500 font-medium text-xs">W</div>
                    <div class="p-2 text-gray-500 font-medium text-xs">T</div>
                    <div class="p-2 text-gray-500 font-medium text-xs">F</div>
                    <div class="p-2 text-gray-500 font-medium text-xs">S</div>
                    <!-- Calendar dates -->
                    <div th:each="day,iter : ${calendarDays}">
                        <a th:href="@{/weekly-feedback(date=${day.date})}"
                           th:text="${day.dayOfMonth}"
                           class="block w-8 h-8 mx-auto flex items-center justify-center transition-all duration-150 text-sm"
                           th:classappend="
                                ${day.selected} ? 'bg-primary text-white rounded-full font-bold ring-2 ring-primary' :
                                (${day.inMonth?.toString() == 'true'} ? 'text-gray-800 hover:bg-primary/10 hover:rounded-full cursor-pointer' : 'text-gray-400 hover:bg-primary/10 hover:rounded-full cursor-pointer')
                           ">
                        </a>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <main id="main-content" class="container mt-8 mx-auto pt-20 md:pt-20 px-5 pb-10 flex-grow">
        <!-- Desktop Layout -->
        <div class="hidden md:flex gap-6 items-start">
            <!-- Calendar Column -->
            <div id="calendar-column" class="w-1/4 bg-gray-50 rounded-lg shadow-sm border border-gray-200 p-5">
                <div class="flex items-center justify-between mb-4">
                    <h2 class="text-lg font-semibold text-gray-800" th:text="${calendarMonthYear}">December 2023</h2>
                    <div class="flex space-x-2">
                        <a th:href="@{/weekly-feedback(date=${prevMonthDate})}" class="p-1 hover:bg-gray-200 rounded transition-colors">
                            <i class="text-gray-600 text-sm fas fa-chevron-left"></i>
                        </a>
                        <a th:href="@{/weekly-feedback(date=${nextMonthDate})}" class="p-1 hover:bg-gray-200 rounded transition-colors">
                            <i class="text-gray-600 text-sm fas fa-chevron-right"></i>
                        </a>
                    </div>
                </div>
                <div class="grid grid-cols-7 gap-1 text-center text-sm">
                    <!-- Days of week -->
                    <div class="p-2 text-gray-500 font-medium">S</div>
                    <div class="p-2 text-gray-500 font-medium">M</div>
                    <div class="p-2 text-gray-500 font-medium">T</div>
                    <div class="p-2 text-gray-500 font-medium">W</div>
                    <div class="p-2 text-gray-500 font-medium">T</div>
                    <div class="p-2 text-gray-500 font-medium">F</div>
                    <div class="p-2 text-gray-500 font-medium">S</div>
                    <!-- Calendar dates -->
                    <div th:each="day,iter : ${calendarDays}">
                        <a th:href="@{/weekly-feedback(date=${day.date})}"
                           th:text="${day.dayOfMonth}"
                           class="block w-8 h-8 mx-auto flex items-center justify-center transition-all duration-150"
                           th:classappend="
                                ${day.selected} ? 'bg-primary text-customTomato rounded-full font-bold ring-2 ring-primary' :
                                (${day.inMonth?.toString() == 'true'} ? 'text-gray-800 hover:bg-primary/10 hover:rounded-full cursor-pointer' : 'text-gray-400 hover:bg-primary/10 hover:rounded-full cursor-pointer')
                           ">
                        </a>
                    </div>
                </div>
            </div>
            <!-- Content Column -->
            <div id="content-column" class="w-3/4 bg-white rounded-lg shadow-sm flex flex-col">
                <!-- Dish Tabs -->
                <div id="dish-tabs" class="flex items-center space-x-6 sm:space-x-8 mb-6">
                    <button th:each="dish,iter : ${dishes}" th:text="${dish.name}"
                        th:classappend="${iter.index} == ${selectedDishIndex} ? 'tab-button active-tab text-base font-semibold text-orange-600 border-b-2 border-orange-600 py-3 shadow-sm transition-all duration-200' : 'tab-button text-base font-medium hover:text-orange-600 py-3 transition-all duration-200'"
                        th:onclick="|window.location='@{/weekly-feedback(date=${selectedDate},dish=${iter.index})}'|">
                        Dish Name
                    </button>
                </div>
                <!-- Main Dish and Feedback Area -->
                <div th:if="${selectedDish != null}" id="main-dish-area" class="flex-grow flex flex-col lg:flex-row border border-gray-200 rounded-xl overflow-hidden">
                    <!-- Left Column: Dish Image and Info -->
                    <div id="dish-info-column" class="w-full lg:w-[60%] p-6 bg-white">
                        <div id="dish-image-container" class="mb-6">
                            <img class="w-full h-96 object-cover rounded-xl shadow-md" th:src="${selectedDish != null ? selectedDish.imageUrl : ''}" th:alt="${selectedDish != null ? selectedDish.name : 'Dish'}">
                        </div>
                        <div id="dish-details">
                            <div class="flex items-center justify-between mb-2">
                                <h1 class="text-2xl sm:text-3xl md:text-4xl lg:text-5xl font-bold font-dmSerifDisplay text-gray-800 break-words break-all" th:text="${selectedDish != null ? selectedDish.name : 'Dish Name'}">Dish Name</h1>
                                <span th:if="${selectedDish != null && selectedDish.mealPeriod != null}" 
                                      class="bg-blue-100 text-blue-800 px-2 py-0.5 rounded text-sm font-medium whitespace-nowrap">
                                    <span th:text="${#strings.capitalize(selectedDish.mealPeriod)}">Lunch</span>
                                </span>
                            </div>
                            <p class="text-lg text-gray-600 mt-2 leading-relaxed break-words" th:text="${selectedDish != null ? selectedDish.description : 'Dish description'}">Dish description</p>
                        </div>
                    </div>
                    <!-- Right Column: Feedback -->
                    <div id="feedback-column" class="w-full lg:w-[40%] bg-gray-50/50 border-l border-gray-200 flex flex-col p-6">
                        <!-- Show login message for unauthenticated users -->
                        <div th:if="${!isAuthenticated}" class="flex-grow flex items-center justify-center">
                            <div class="text-center">
                                <h3 class="text-lg font-semibold text-gray-800 mb-2">Sign in to interact</h3>
                                <p class="text-gray-600 mb-4">To provide your thoughts or react to this dish, please sign in to your account.</p>
                                <a th:href="@{/login}" class="inline-flex items-center px-4 py-2 bg-primary text-customTomato font-medium rounded-lg hover:bg-primary/80 transition-colors">
                                    <i class="fa-solid fa-sign-in-alt mr-2"></i>
                                    Sign In
                                </a>
                            </div>
                        </div>
                        
                        <!-- Show comments for authenticated users only -->
                        <div th:if="${isAuthenticated && !selectedDate.isAfter(T(java.time.LocalDate).now())}" id="comments-list" class="flex-grow space-y-5 pr-2 -mr-2 overflow-y-auto h-64">
                            <!-- Comments will be loaded here by JS -->
                        </div>
                        <div class="mt-4 pt-4 border-t border-gray-200">
                            <!-- Error message -->
                            <div th:if="${error}" class="mb-3 p-2 bg-red-100 border border-red-300 text-red-700 rounded text-sm">
                                <span th:text="${error}">Comment cannot be empty.</span>
                            </div>
                            <div th:if="${isAuthenticated && selectedDish != null && !selectedDish.isEmpty() && !selectedDate.isAfter(T(java.time.LocalDate).now())}" class="space-y-3">
                                <!-- Reactions and Comments Row -->
                                <div class="flex items-center justify-between py-2 border-t border-gray-100">
                                    <!-- Left: Reaction Button -->
                                    <div class="flex items-center space-x-4">
                                        <!-- Desktop Reaction System -->
                                        <div class="relative">
                                            <!-- Main reaction button with emoji and text -->
                                            <button id="reaction-btn" type="button" class="flex items-center space-x-1.5 text-gray-600 hover:text-gray-800 focus:outline-none transition-colors duration-200 py-1">
                                                <div class="relative flex items-center">
                                                    <span id="reaction-icon" class="text-lg transition-all duration-200" 
                                                          data-reaction-type="NONE"
                                                          th:data-reaction-type="${selectedDish != null && selectedDish.userReactionType != null ? selectedDish.userReactionType : 'NONE'}">
                                                        <div id="main-reaction-animation" 
                                                             style="width: 24px; height: 24px;">
                                                        </div>
                                                    </span>
                                                    <span id="reaction-text" class="font-medium text-sm ml-1 text-gray-600">
                                                        Good
                                                    </span>
                                                </div>
                                            </button>
                                            <!-- Lottie Animation Hover Menu -->
                                            <div id="reaction-menu" class="absolute bottom-full left-0 mb-3 bg-white border border-gray-200 rounded-full shadow-xl p-2 hidden z-50 transform scale-100 transition-all duration-200">
                                                <div class="flex space-x-1">
                                                    <button class="reaction-option p-2 hover:scale-125 transition-all duration-200 rounded-full hover:bg-gray-50" data-reaction="GOOD" data-animation="good.json" data-text="Good" title="Good">
                                                        <div class="reaction-animation" data-animation="good.json" style="width: 32px; height: 32px;"></div>
                                                    </button>
                                                    <button class="reaction-option p-2 hover:scale-125 transition-all duration-200 rounded-full hover:bg-gray-50" data-reaction="OKAY" data-animation="okayish.json" data-text="Okay" title="Okay">
                                                        <div class="reaction-animation" data-animation="okayish.json" style="width: 32px; height: 32px;"></div>
                                                    </button>
                                                    <button class="reaction-option p-2 hover:scale-125 transition-all duration-200 rounded-full hover:bg-gray-50" data-reaction="NOT_GONNA_WORK" data-animation="not-gonna-work.json" data-text="Not Gonna Work" title="Not Gonna Work">
                                                        <div class="reaction-animation" data-animation="not-gonna-work.json" style="width: 32px; height: 32px;"></div>
                                                    </button>
                                                    <button class="reaction-option p-2 hover:scale-125 transition-all duration-200 rounded-full hover:bg-gray-50" data-reaction="NEEDS_IMPROVEMENT" data-animation="needs-improvement.json" data-text="Needs Improvement" title="Needs Improvement">
                                                        <div class="reaction-animation" data-animation="needs-improvement.json" style="width: 32px; height: 32px;"></div>
                                                    </button>
                                                </div>
                                            </div>
                                        </div>
                                    </div>
                                    
                                    <!-- Right: Comments Count -->
                                    <div class="flex items-center space-x-1.5 text-gray-600">
                                        <i class="fa-regular fa-comment text-lg text-blue-500"></i>
                                        <span class="font-medium text-sm" th:text="${selectedDish != null ? selectedDish.commentsCount : 0}">0</span>
                                        <span class="text-sm ml-1">Comments</span>
                                    </div>
                                </div>
                            </div>
                            <div th:if="${isAuthenticated && !selectedDate.isAfter(T(java.time.LocalDate).now())}" id="feedback-form" class="flex items-center space-x-2">
                                <form th:action="@{/weekly-feedback/feedback}" method="post" class="flex w-full">
                                    <input type="hidden" name="date" th:value="${selectedDate}">
                                    <input type="hidden" name="dishId" th:value="${selectedDish != null ? selectedDish.id : ''}">
                                    <input type="text" name="comment" placeholder="Share your thoughts..." class="w-full px-4 mr-1 py-2 text-sm border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-primary/50 focus:border-primary transition">
                                    <button type="submit" class="bg-gray-800 text-white font-semibold px-4 py-2 rounded-lg hover:bg-gray-900 transition-colors text-sm">Submit</button>
                                </form>
                            </div>
                        </div>
                    </div>
                </div>
                <div th:if="${selectedDish == null}" class="text-center text-gray-500 py-10">
                    No dishes available for this date.
                </div>
            </div>
        </div>

        <!-- Mobile Layout -->
        <div class="md:hidden pt-28">
            <!-- Dish Tabs - Horizontally Scrollable -->
            <div id="mobile-dish-tabs" class="mobile-dish-tabs flex items-center space-x-6 px-4 py-5 overflow-x-auto scrollbar-hide">
                <button th:each="dish,iter : ${dishes}" th:text="${dish.name}"
                    th:classappend="${iter.index} == ${selectedDishIndex} ? 'tab-button active-tab text-base font-semibold text-orange-600 border-b-2 border-orange-600 py-3 shadow-sm transition-all duration-200 whitespace-nowrap flex-shrink-0' : 'tab-button text-base font-medium hover:text-orange-600 py-3 transition-all duration-200 whitespace-nowrap flex-shrink-0'"
                    th:onclick="|window.location='@{/weekly-feedback(date=${selectedDate},dish=${iter.index})}'|">
                    Dish Name
                </button>
            </div>

            <!-- Mobile Dish Content - Instagram-style Post -->
            <div th:if="${selectedDish != null}" class="mobile-dish-post bg-white">
                <!-- Dish Image - Instagram-style square/landscape -->
                <div class="w-full relative overflow-hidden" style="aspect-ratio: 1/1; min-height: 250px; max-height: 400px;">
                    <img class="w-full h-full object-cover mobile-dish-image" th:src="${selectedDish != null ? selectedDish.imageUrl : ''}" th:alt="${selectedDish != null ? selectedDish.name : 'Dish'}">
                </div>
                
                <!-- Post Content - Instagram-style padding and spacing -->
                <div class="px-4 py-3 space-y-3">
                    <!-- Dish Title and Meal Period -->
                    <div class="flex items-start justify-between">
                        <h1 class="mobile-dish-title text-lg sm:text-xl font-bold text-gray-900 break-words flex-1 mr-3" th:text="${selectedDish != null ? selectedDish.name : 'Dish Name'}">Dish Name</h1>
                        <span th:if="${selectedDish != null && selectedDish.mealPeriod != null}" 
                              class="bg-blue-100 text-blue-800 px-2 py-1 rounded-full text-xs font-medium whitespace-nowrap flex-shrink-0">
                            <span th:text="${#strings.capitalize(selectedDish.mealPeriod)}">Lunch</span>
                        </span>
                    </div>
                    
                    <!-- Dish Description -->
                    <p class="mobile-dish-description text-gray-700 text-sm leading-relaxed break-words" th:text="${selectedDish != null ? selectedDish.description : 'Dish description'}">Dish description</p>
                    
                    <!-- Reactions and Comments Row - Instagram-style -->
                    <div th:if="${isAuthenticated && selectedDish != null && !selectedDish.isEmpty() && !selectedDate.isAfter(T(java.time.LocalDate).now())}" class="flex items-center justify-between py-2 border-t border-gray-100">
                        <!-- Left: Reaction Button -->
                        <div class="flex items-center space-x-4">
                            <!-- Mobile Reaction System -->
                            <div class="relative">
                                <button id="mobile-reaction-btn" type="button" class="flex items-center space-x-2 text-gray-600 hover:text-gray-800 focus:outline-none transition-colors duration-200 py-1">
                                    <span id="mobile-reaction-icon" class="text-xl transition-all duration-200" 
                                          data-reaction-type="NONE"
                                          th:data-reaction-type="${selectedDish != null && selectedDish.userReactionType != null ? selectedDish.userReactionType : 'NONE'}">
                                        <div id="mobile-main-reaction-animation" 
                                             style="width: 28px; height: 28px;">
                                        </div>
                                    </span>
                                    <span id="mobile-reaction-text" class="font-medium text-sm text-gray-600">
                                        Good
                                    </span>
                                </button>
                                <!-- Mobile Reaction Menu -->
                                <div id="mobile-reaction-menu" class="absolute bottom-full left-0 mb-3 bg-white border border-gray-200 rounded-full shadow-xl p-2 hidden z-50 transform scale-100 transition-all duration-200">
                                    <div class="flex space-x-1">
                                        <button class="reaction-option p-2 hover:scale-125 transition-all duration-200 rounded-full hover:bg-gray-50" data-reaction="GOOD" data-animation="good.json" data-text="Good" title="Good">
                                            <div class="reaction-animation" data-animation="good.json" style="width: 32px; height: 32px;"></div>
                                        </button>
                                        <button class="reaction-option p-2 hover:scale-125 transition-all duration-200 rounded-full hover:bg-gray-50" data-reaction="OKAY" data-animation="okayish.json" data-text="Okay" title="Okay">
                                            <div class="reaction-animation" data-animation="okayish.json" style="width: 32px; height: 32px;"></div>
                                        </button>
                                        <button class="reaction-option p-2 hover:scale-125 transition-all duration-200 rounded-full hover:bg-gray-50" data-reaction="NOT_GONNA_WORK" data-animation="not-gonna-work.json" data-text="Not Gonna Work" title="Not Gonna Work">
                                            <div class="reaction-animation" data-animation="not-gonna-work.json" style="width: 32px; height: 32px;"></div>
                                        </button>
                                        <button class="reaction-option p-2 hover:scale-125 transition-all duration-200 rounded-full hover:bg-gray-50" data-reaction="NEEDS_IMPROVEMENT" data-animation="needs-improvement.json" data-text="Needs Improvement" title="Needs Improvement">
                                            <div class="reaction-animation" data-animation="needs-improvement.json" style="width: 32px; height: 32px;"></div>
                                        </button>
                                    </div>
                                </div>
                            </div>
                        </div>
                        
                        <!-- Right: Comments Button -->
                        <button id="mobile-comments-btn" type="button" class="flex items-center space-x-2 text-gray-600 focus:outline-none py-1">
                            <i class="fa-regular fa-comment text-lg"></i>
                            <span class="font-medium text-sm" th:text="${selectedDish != null ? selectedDish.commentsCount : 0} + ' Comments'">0 Comments</span>
                        </button>
                    </div>
                    
                    <!-- Login Message for Unauthenticated Users -->
                    <div th:if="${!isAuthenticated}" class="text-center py-4 border-t border-gray-100">
                        <div class="bg-gray-50 border border-gray-200 rounded-lg p-4">
                            <h3 class="text-base font-semibold text-gray-800 mb-2">Sign in to interact</h3>
                            <p class="text-gray-600 mb-3 text-sm">To provide your thoughts or react to this dish, please sign in to your account.</p>
                            <a th:href="@{/login}" class="inline-flex items-center px-4 py-2 bg-primary text-customTomato font-medium rounded-lg hover:bg-primary/80 transition-colors text-sm">
                                <i class="fa-solid fa-sign-in-alt mr-2"></i>
                                Sign In
                            </a>
                        </div>
                    </div>
                </div>
            </div>
            
            <div th:if="${selectedDish == null}" class="text-center text-gray-500 py-10">
                No dishes available for this date.
            </div>
        </div>
    </main>

    <!-- Mobile Comments Modal -->
    <div id="mobile-comments-modal" class="hidden md:hidden fixed inset-0 bg-black bg-opacity-50 z-50 flex items-end">
        <div class="w-full bg-white rounded-t-2xl shadow-xl transform transition-transform duration-300 ease-out translate-y-0 flex flex-col max-h-[85vh]">
            <!-- Modal Header -->
            <div class="flex items-center justify-between p-4 border-b border-gray-200 bg-white rounded-t-2xl">
                <h3 class="text-lg font-semibold text-gray-800">Comments</h3>
                <button id="close-comments-modal" class="text-gray-500 hover:text-gray-700 p-2 rounded-full hover:bg-gray-100 transition-colors">
                    <i class="fa-solid fa-times text-lg"></i>
                </button>
            </div>
            
            <!-- Modal Handle for better UX -->
            <div class="flex justify-center py-2 bg-white">
                <div class="w-10 h-1 bg-gray-300 rounded-full"></div>
            </div>
            
            <!-- Comments List -->
            <div id="mobile-comments-list" class="flex-1 overflow-y-auto px-4 py-2 space-y-4 min-h-0 relative">
                <!-- Show simple message for unauthenticated users -->
                <div th:if="${!isAuthenticated}" class="flex items-center justify-center h-full min-h-[200px]">
                    <div class="text-center">
                        <h3 class="text-lg font-semibold text-gray-800 mb-2">Sign in to see comments</h3>
                        <p class="text-gray-600">Please sign in to view and add comments.</p>
                    </div>
                </div>
                <!-- Comments will be loaded here by JS for authenticated users -->
                
                <!-- Scroll indicator for many comments -->
                <div id="mobile-scroll-indicator" class="hidden sticky bottom-0 left-0 right-0 text-center py-2 bg-gradient-to-t from-white to-transparent">
                    <div class="text-xs text-gray-500 flex items-center justify-center space-x-1">
                        <i class="fa-solid fa-chevron-down text-xs"></i>
                        <span>Scroll for more comments</span>
                    </div>
                </div>
            </div>
            
            <!-- Comment Input -->
            <div th:if="${!selectedDate.isAfter(T(java.time.LocalDate).now())}" class="border-t border-gray-200 p-4 bg-white rounded-b-2xl">
                <!-- Error message -->
                <div th:if="${error}" class="mb-3 p-2 bg-red-100 border border-red-300 text-red-700 rounded text-sm">
                    <span th:text="${error}">Comment cannot be empty.</span>
                </div>
                
                <!-- Show comment form for authenticated users only -->
                <form th:if="${isAuthenticated}" id="mobile-comment-form" th:action="@{/weekly-feedback/feedback}" method="post" class="flex items-center space-x-3">
                    <input type="hidden" name="date" th:value="${selectedDate}">
                    <input type="hidden" name="dishId" th:value="${selectedDish != null ? selectedDish.id : ''}">
                    <div class="flex-1 relative">
                        <input type="text" name="comment" placeholder="Write a comment..." class="w-full px-4 py-3 pr-12 text-sm border border-gray-300 rounded-full focus:outline-none focus:ring-2 focus:ring-primary/50 focus:border-primary transition">
                    </div>
                    <button type="submit" class="text-primary p-2 rounded-full hover:bg-primary/10 transition-colors">
                        <i class="fa-regular fa-paper-plane text-lg"></i>
                    </button>
                </form>
            </div>
        </div>
    </div>
    <div th:replace="fragments/layout :: footer"></div>
    <script th:inline="javascript">
    /*<![CDATA[*/
    let currentPage = 0;
    const pageSize = 20;
    let currentDishId = /*[[${selectedDish != null ? selectedDish.id : 0}]]*/ 0;
    
    let currentDate = /*[[${selectedDate}]]*/ '';

    // Lottie animation instances
    let mainReactionAnim = null;
    let mobileMainReactionAnim = null;
    let menuAnimations = [];
    let mobileMenuAnimations = [];

    // Initialize Lottie animations
    function initializeLottieAnimations() {
        // Initialize main reaction animation
        const mainContainer = document.getElementById('main-reaction-animation');
        if (mainContainer) {
            mainReactionAnim = lottie.loadAnimation({
                container: mainContainer,
                renderer: 'svg',
                loop: true,
                autoplay: true,
                path: '/images/reaction-menus/good.json'
            });
        }

        // Initialize mobile main reaction animation
        const mobileContainer = document.getElementById('mobile-main-reaction-animation');
        if (mobileContainer) {
            mobileMainReactionAnim = lottie.loadAnimation({
                container: mobileContainer,
                renderer: 'svg',
                loop: true,
                autoplay: true,
                path: '/images/reaction-menus/good.json'
            });
        }

        // Initialize menu animations
        const menuElements = document.querySelectorAll('#reaction-menu .reaction-animation');
        menuElements.forEach(element => {
            const animationPath = `/images/reaction-menus/${element.dataset.animation}`;
            const anim = lottie.loadAnimation({
                container: element,
                renderer: 'svg',
                loop: true,
                autoplay: true,
                path: animationPath
            });
            menuAnimations.push(anim);
        });

        // Initialize mobile menu animations
        const mobileMenuElements = document.querySelectorAll('#mobile-reaction-menu .reaction-animation');
        mobileMenuElements.forEach(element => {
            const animationPath = `/images/reaction-menus/${element.dataset.animation}`;
            const anim = lottie.loadAnimation({
                container: element,
                renderer: 'svg',
                loop: true,
                autoplay: true,
                path: animationPath
            });
            mobileMenuAnimations.push(anim);
        });
    }

    // Helper function to get CSRF token from meta tag
    function getCsrfToken() {
        const metaTag = document.querySelector('meta[name="_csrf"]');
        return metaTag ? metaTag.getAttribute('content') : '';
    }

    // Helper function to set redirect cookie and navigate to login
    function setRedirectAndLogin() {
        const currentUrl = window.location.pathname + window.location.search + window.location.hash;
        document.cookie = "redirectAfterLogin=" + encodeURIComponent(currentUrl) + "; path=/";
        window.location.href = '/login';
    }

    async function loadComments(reset = false) {
        const commentsList = document.getElementById('comments-list');
        if (reset) commentsList.innerHTML = '';
        if (!currentDishId || !currentDate) return;
        // Remove quotes if present
        //let dateParam = currentDate.replace(/^['"]|['"]$/g, '');
        const res = await fetch(`/weekly-feedback/comments?dishId=${currentDishId}&date=${currentDate}&page=${currentPage}&size=${pageSize}`);
        const data = await res.json();
        if (!data.comments || (data.comments.length === 0 && currentPage === 0)) {
            commentsList.innerHTML = '<div class="text-gray-500 text-sm">No comments yet.</div>';
        } else {
            data.comments.forEach(comment => {
                commentsList.innerHTML += `
                    <div class="flex items-start space-x-3">
                        <img src="${comment.avatarUrl}" alt="${comment.userName}" class="w-10 h-10 rounded-full object-cover border-2 border-white shadow referrerpolicy="no-referrer"">
                        <div>
                            <p class="font-semibold text-gray-800 text-sm">${comment.userName}</p>
                            <p class="text-gray-600 text-sm">${comment.text}</p>
                        </div>
                    </div>
                `;
            });
        }
        
    }

    async function loadMobileComments(reset = false) {
        const mobileCommentsList = document.getElementById('mobile-comments-list');
        const scrollIndicator = document.getElementById('mobile-scroll-indicator');
        if (!mobileCommentsList) return;
        
        if (reset) {
            mobileCommentsList.innerHTML = '';
            currentPage = 0;
        }
        
        if (!currentDishId || !currentDate) {
            mobileCommentsList.innerHTML = '<div class="text-gray-500 text-sm text-center py-8">No dish selected.</div>';
            return;
        }
        
        try {
            // Show loading state
            if (reset) {
                mobileCommentsList.innerHTML = '<div class="comments-loading"><div class="spinner"></div><span>Loading comments...</span></div>';
            }
            
            // Get the comment count from the dish data
            const commentCountElement = document.querySelector('#mobile-comments-btn span');
            const commentCount = commentCountElement ? parseInt(commentCountElement.textContent, 10) : 0;
            
            // Load all comments for mobile view using the actual comment count
            const res = await fetch(`/weekly-feedback/comments?dishId=${currentDishId}&date=${currentDate}&page=0&size=${commentCount}`);
            
            if (!res.ok) {
                throw new Error('Failed to load comments');
            }
            
            const data = await res.json();
            
            if (reset) {
                mobileCommentsList.innerHTML = '';
            }
            
            if (!data.comments || (data.comments.length === 0 && currentPage === 0)) {
                mobileCommentsList.innerHTML = '<div class="text-gray-500 text-sm text-center py-8">No comments yet. Be the first to comment!</div>';
                if (scrollIndicator) scrollIndicator.classList.add('hidden');
            } else {
                data.comments.forEach(comment => {
                    mobileCommentsList.innerHTML += `
                        <div class="comment-item flex items-start space-x-3">
                            <img src="${comment.avatarUrl}" alt="${comment.userName}" class="w-10 h-10 rounded-full object-cover border-2 border-white shadow flex-shrink-0">
                            <div class="flex-1">
                                <p class="font-semibold text-gray-800 text-sm">${comment.userName}</p>
                                <p class="text-gray-600 text-sm">${comment.text}</p>
                            </div>
                        </div>
                    `;
                });
                
                // Check if scroll is needed and show indicator
                setTimeout(() => {
                    if (mobileCommentsList.scrollHeight > mobileCommentsList.clientHeight) {
                        if (scrollIndicator) {
                            scrollIndicator.classList.remove('hidden');
                            // Hide indicator after scroll or timeout
                            setTimeout(() => {
                                if (scrollIndicator) scrollIndicator.classList.add('hidden');
                            }, 3000);
                        }
                    }
                }, 100);
                
                // Scroll to bottom to show the latest comment
                if (reset) {
                    setTimeout(() => {
                        mobileCommentsList.scrollTop = mobileCommentsList.scrollHeight;
                    }, 100);
                }
                
                // Add scroll event listener to hide indicator
                mobileCommentsList.addEventListener('scroll', function() {
                    if (scrollIndicator && !scrollIndicator.classList.contains('hidden')) {
                        scrollIndicator.classList.add('hidden');
                    }
                }, { once: true });
            }
        } catch (error) {
            console.error('Error loading mobile comments:', error);
            mobileCommentsList.innerHTML = '<div class="text-red-500 text-sm text-center py-8">Failed to load comments. Please try again.</div>';
            if (scrollIndicator) scrollIndicator.classList.add('hidden');
        }
    }

    document.addEventListener('DOMContentLoaded', function() {
        // Initialize Lottie animations
        initializeLottieAnimations();
        
        // Add click handlers for all login links
        const loginLinks = document.querySelectorAll('a[href="/login"]');
        loginLinks.forEach(link => {
            link.addEventListener('click', function(e) {
                e.preventDefault();
                setRedirectAndLogin();
            });
        });

        // Scroll active dish tab into view on page load
        function scrollActiveTabIntoView() {
            const mobileDishTabs = document.getElementById('mobile-dish-tabs');
            const activeTab = mobileDishTabs?.querySelector('.active-tab');
            
            if (mobileDishTabs && activeTab) {
                // Calculate the scroll position to center the active tab
                const containerWidth = mobileDishTabs.offsetWidth;
                const tabLeft = activeTab.offsetLeft;
                const tabWidth = activeTab.offsetWidth;
                const scrollLeft = tabLeft - (containerWidth / 2) + (tabWidth / 2);
                
                // Instant scroll to the active tab (no animation)
                mobileDishTabs.scrollLeft = Math.max(0, scrollLeft);
            }
        }

        // Mobile menu functionality
        const mobileMenuButton = document.getElementById('mobile-menu-button');
        const mobileMenu = document.getElementById('mobile-menu');
        
        if (mobileMenuButton && mobileMenu) {
            mobileMenuButton.addEventListener('click', function(e) {
                e.preventDefault();
                e.stopPropagation();
                
                const isHidden = mobileMenu.classList.contains('hidden');
                
                if (isHidden) {
                    mobileMenu.classList.remove('hidden');
                    mobileMenu.classList.add('block');
                    mobileMenuButton.innerHTML = '<i class="fa-solid fa-times text-xl"></i>';
                } else {
                    mobileMenu.classList.add('hidden');
                    mobileMenu.classList.remove('block');
                    mobileMenuButton.innerHTML = '<i class="fa-solid fa-bars text-xl"></i>';
                }
            });
            
            // Close menu when clicking outside
            document.addEventListener('click', function(event) {
                const isClickInsideMenu = mobileMenu.contains(event.target);
                const isClickOnButton = mobileMenuButton.contains(event.target);
                
                if (!isClickInsideMenu && !isClickOnButton && !mobileMenu.classList.contains('hidden')) {
                    mobileMenu.classList.add('hidden');
                    mobileMenu.classList.remove('block');
                    mobileMenuButton.innerHTML = '<i class="fa-solid fa-bars text-xl"></i>';
                }
            });
            
            // Prevent menu from closing when clicking inside menu
            mobileMenu.addEventListener('click', function(e) {
                e.stopPropagation();
            });
        }

        // Mobile calendar modal functionality
        const mobileCalendarToggle = document.getElementById('mobile-calendar-toggle');
        const mobileCalendarModal = document.getElementById('mobile-calendar-modal');
        const closeCalendarModal = document.getElementById('close-calendar-modal');
        
        if (mobileCalendarToggle && mobileCalendarModal) {
            mobileCalendarToggle.addEventListener('click', function() {
                mobileCalendarModal.classList.remove('hidden');
            });
            
            closeCalendarModal.addEventListener('click', function() {
                mobileCalendarModal.classList.add('hidden');
            });
            
            // Close modal when clicking outside
            mobileCalendarModal.addEventListener('click', function(e) {
                if (e.target === mobileCalendarModal) {
                    mobileCalendarModal.classList.add('hidden');
                }
            });
        }

        // Desktop comments functionality - only for authenticated users
        const isAuthenticated = /*[[${isAuthenticated}]]*/ false;
        if (isAuthenticated && document.getElementById('comments-list') && currentDishId && currentDate) {
            currentPage = 0;
            loadComments(true);
        }
        
        // Desktop reaction functionality - only for authenticated users
        const reactionBtn = document.getElementById('reaction-btn');
        const reactionMenu = document.getElementById('reaction-menu');
        const reactionText = document.getElementById('reaction-text');
        const reactionIcon = document.getElementById('reaction-icon');

        // Initialize reaction state from server data - only for authenticated users
        if (isAuthenticated && reactionIcon) {
            // Initialize the main reaction button
            const userReactionType = /*[[${selectedDish != null ? selectedDish.userReactionType : null}]]*/ null;
            
            // Wait for animations to load before updating
            setTimeout(() => {
                updateReactionIcon(userReactionType);
                // Also update the text based on the user's reaction type
                updateReactionTextAndStyle(userReactionType, true);
            }, 100);
        }

        if (isAuthenticated && reactionBtn) {
            let menuTimeout;
            
            // Show menu on hover
            reactionBtn.addEventListener('mouseenter', function() {
                clearTimeout(menuTimeout);
                reactionMenu.classList.remove('hidden');
            });

            // Hide menu with delay when leaving the button
            reactionBtn.addEventListener('mouseleave', function() {
                menuTimeout = setTimeout(() => {
                    reactionMenu.classList.add('hidden');
                }, 100);
            });

            // Keep menu visible when hovering over menu
            reactionMenu.addEventListener('mouseenter', function() {
                clearTimeout(menuTimeout);
            });

            // Hide menu when leaving the menu
            reactionMenu.addEventListener('mouseleave', function() {
                reactionMenu.classList.add('hidden');
            });

            // Handle direct click on main reaction button
            reactionBtn.addEventListener('click', function(e) {
                // Check if user is authenticated first
                const isAuthenticated = /*[[${isAuthenticated}]]*/ false;
                if (!isAuthenticated) {
                    // Save current URL in a cookie and redirect to login
                    var currentUrl = window.location.pathname + window.location.search + window.location.hash;
                    document.cookie = "redirectAfterLogin=" + encodeURIComponent(currentUrl) + "; path=/";
                    window.location.href = '/login';
                    return;
                }

                const currentReactionType = reactionIcon.dataset.reactionType;
                
                // If no reaction is selected, set Good reaction
                if (currentReactionType === 'NONE' || currentReactionType === null) {
                    // Send request to set Good reaction
                    fetch('/api/reactions', {
                        method: 'POST',
                        headers: { 
                            'Content-Type': 'application/json',
                            'X-XSRF-TOKEN': getCsrfToken()
                        },
                        body: JSON.stringify({ dishId: currentDishId, reactionType: 'GOOD', date: currentDate })
                    })
                    .then(res => {
                        if (res.redirected) {
                            // Handle redirect to login
                            window.location.href = res.url;
                            return;
                        }
                        if (!res.ok) {
                            return res.json().then(errorData => {
                                throw new Error(errorData.error || `HTTP ${res.status}: ${res.statusText}`);
                            }).catch(() => {
                                throw new Error(`HTTP ${res.status}: ${res.statusText}`);
                            });
                        }
                        return res.json();
                    })
                    .then(data => {
                        if (data) { // Only process if we got data (not redirected)
                            // Update reaction count display with server response
                            //updateReactionDisplay(data.reactionCounts, data.userReactionType);
                            
                            // Update main reaction button icon
                            updateReactionIcon(data.userReactionType);
                            
                            // Update text based on user reaction
                            updateReactionTextAndStyle(data.userReactionType, true);
                        }
                    })
                    .catch(error => {
                        console.error('Error submitting reaction:', error);
                        alert('Failed to submit reaction. Please try again. Error: ' + error.message);
                    });
                } else {
                    // If reaction is already selected, remove it by sending the same reaction type
                    fetch('/api/reactions', {
                        method: 'POST',
                        headers: { 
                            'Content-Type': 'application/json',
                            'X-XSRF-TOKEN': getCsrfToken()
                        },
                        body: JSON.stringify({ dishId: currentDishId, reactionType: currentReactionType, date: currentDate })
                    })
                    .then(res => {
                        if (res.redirected) {
                            // Handle redirect to login
                            window.location.href = res.url;
                            return;
                        }
                        if (!res.ok) {
                            return res.json().then(errorData => {
                                throw new Error(errorData.error || `HTTP ${res.status}: ${res.statusText}`);
                            }).catch(() => {
                                throw new Error(`HTTP ${res.status}: ${res.statusText}`);
                            });
                        }
                        return res.json();
                    })
                    .then(data => {
                        if (data) { // Only process if we got data (not redirected)
                            // Update main reaction button icon
                            updateReactionIcon(data.userReactionType);
                            
                            // Update text based on user reaction
                            updateReactionTextAndStyle(data.userReactionType, true);
                        }
                    })
                    .catch(error => {
                        console.error('Error removing reaction:', error);
                        alert('Failed to remove reaction. Please try again. Error: ' + error.message);
                    });
                }
            });

            // Handle reaction option clicks directly
            reactionMenu.addEventListener('click', function(e) {
                const reactionOption = e.target.closest('.reaction-option');
                if (!reactionOption) return;

                // Check if user is authenticated first
                const isAuthenticated = /*[[${isAuthenticated}]]*/ false;
                if (!isAuthenticated) {
                    // Save current URL in a cookie and redirect to login
                    var currentUrl = window.location.pathname + window.location.search + window.location.hash;
                    document.cookie = "redirectAfterLogin=" + encodeURIComponent(currentUrl) + "; path=/";
                    window.location.href = '/login';
                    return;
                }

                const reactionType = reactionOption.dataset.reaction;
                const animation = reactionOption.dataset.animation;
                const text = reactionOption.dataset.text;
                const currentReactionType = reactionIcon.dataset.reactionType;

                // Send request with the actual reaction type
                fetch('/api/reactions', {
                    method: 'POST',
                    headers: { 
                        'Content-Type': 'application/json',
                        'X-XSRF-TOKEN': getCsrfToken()
                    },
                    body: JSON.stringify({ dishId: currentDishId, reactionType: reactionType, date: currentDate })
                })
                .then(res => {
                    if (res.redirected) {
                        // Handle redirect to login
                        window.location.href = res.url;
                        return;
                    }
                    if (!res.ok) {
                        return res.json().then(errorData => {
                            throw new Error(errorData.error || `HTTP ${res.status}: ${res.statusText}`);
                        }).catch(() => {
                            throw new Error(`HTTP ${res.status}: ${res.statusText}`);
                        });
                    }
                    return res.json();
                })
                .then(data => {
                    if (data) { // Only process if we got data (not redirected)
                        // Update main reaction button icon
                        updateReactionIcon(data.userReactionType);
                        
                        // Update text based on user reaction
                        updateReactionTextAndStyle(data.userReactionType, true);
                    }
                })
                .catch(error => {
                    console.error('Error submitting reaction:', error);
                    alert('Failed to submit reaction. Please try again. Error: ' + error.message);
                });

                // Hide menu after selection
                reactionMenu.classList.add('hidden');
            });
        }

        // Helper function to update reaction text and styling
        function updateReactionTextAndStyle(reactionType, isDesktop = true) {
            const textElement = isDesktop ? document.getElementById('reaction-text') : document.getElementById('mobile-reaction-text');
            if (!textElement) return;
            
            const textMap = {
                'GOOD': { text: 'Good', class: 'text-green-600' },
                'OKAY': { text: 'Okay', class: 'text-yellow-600' },
                'NOT_GONNA_WORK': { text: 'Not Gonna Work', class: 'text-red-600' },
                'NEEDS_IMPROVEMENT': { text: 'Needs Improvement', class: 'text-orange-600' }
            };
            
            // Remove all color classes
            textElement.classList.remove('text-green-600', 'text-yellow-600', 'text-red-600', 'text-orange-600', 'text-gray-600');
            
            if (reactionType && textMap[reactionType]) {
                textElement.textContent = textMap[reactionType].text;
                textElement.classList.add(textMap[reactionType].class);
            } else {
                textElement.textContent = 'Good';
                textElement.classList.add('text-gray-600');
            }
        }

        function updateReactionIcon(userReactionType) {
            if (!reactionIcon || !mainReactionAnim) return;
            
            // Update the main reaction button animation
            if (userReactionType) {
                const animationMap = {
                    'GOOD': '/images/reaction-menus/good.json',
                    'OKAY': '/images/reaction-menus/okayish.json',
                    'NOT_GONNA_WORK': '/images/reaction-menus/not-gonna-work.json',
                    'NEEDS_IMPROVEMENT': '/images/reaction-menus/needs-improvement.json'
                };
                const newPath = animationMap[userReactionType] || '/images/reaction-menus/good.json';
                
                // Destroy and recreate animation with new path
                mainReactionAnim.destroy();
                const container = document.getElementById('main-reaction-animation');
                mainReactionAnim = lottie.loadAnimation({
                    container: container,
                    renderer: 'svg',
                    loop: true,
                    autoplay: true,
                    path: newPath
                });
                
                reactionIcon.dataset.reactionType = userReactionType;
            } else {
                // Reset to default animation
                mainReactionAnim.destroy();
                const container = document.getElementById('main-reaction-animation');
                mainReactionAnim = lottie.loadAnimation({
                    container: container,
                    renderer: 'svg',
                    loop: true,
                    autoplay: true,
                    path: '/images/reaction-menus/good.json'
                });
                
                reactionIcon.dataset.reactionType = 'NONE';
            }
        }

        function getReactionText(reactionType) {
            const textMap = {
                'GOOD': 'Good',
                'OKAY': 'Okay',
                'NOT_GONNA_WORK': 'Not Gonna Work',
                'NEEDS_IMPROVEMENT': 'Needs Improvement'
            };
            return textMap[reactionType] || 'Good';
        }

        function getReactionColorClass(reactionType) {
            const colorMap = {
                'GOOD': 'text-green-600',
                'OKAY': 'text-yellow-600',
                'NOT_GONNA_WORK': 'text-red-600',
                'NEEDS_IMPROVEMENT': 'text-orange-600'
            };
            return colorMap[reactionType] || 'text-gray-600';
        }

        // Mobile reaction functionality - only for authenticated users
        const mobileReactionBtn = document.getElementById('mobile-reaction-btn');
        const mobileReactionMenu = document.getElementById('mobile-reaction-menu');
        const mobileReactionText = document.getElementById('mobile-reaction-text');
        const mobileReactionIcon = document.getElementById('mobile-reaction-icon');

        // Initialize mobile reaction state from server data - only for authenticated users
        if (isAuthenticated && mobileReactionIcon) {
            // Initialize the main reaction button
            const mobileUserReactionType = /*[[${selectedDish != null ? selectedDish.userReactionType : null}]]*/ null;
            
            // Wait for animations to load before updating
            setTimeout(() => {
                updateMobileReactionIcon(mobileUserReactionType);
                // Also update the text based on the user's reaction type
                updateReactionTextAndStyle(mobileUserReactionType, false);
            }, 100);
        }

        if (isAuthenticated && mobileReactionBtn) {
            let mobileMenuTimeout;
            
            // Show menu on hover
            mobileReactionBtn.addEventListener('mouseenter', function() {
                clearTimeout(mobileMenuTimeout);
                mobileReactionMenu.classList.remove('hidden');
            });

            // Hide menu with delay when leaving the button
            mobileReactionBtn.addEventListener('mouseleave', function() {
                mobileMenuTimeout = setTimeout(() => {
                    mobileReactionMenu.classList.add('hidden');
                }, 100);
            });

            // Keep menu visible when hovering over menu
            mobileReactionMenu.addEventListener('mouseenter', function() {
                clearTimeout(mobileMenuTimeout);
            });

            // Hide menu when leaving the menu
            mobileReactionMenu.addEventListener('mouseleave', function() {
                mobileReactionMenu.classList.add('hidden');
            });

            // --- Long press to open reaction menu (mobile) + touch feedback ---
            const LONG_PRESS_MS = 450;
            const MOVE_TOLERANCE_PX = 10;
            let mobileLongPressTimer = null;
            let mobileLongPressTriggered = false;
            let suppressMobileClick = false;
            let touchStartX = 0;
            let touchStartY = 0;
            let lastQuickTapTs = 0; // prevent duplicate click after touch
            let menuSelectionArmed = false; // require touchstart in menu before selecting

            // Helper to send mobile reaction and update UI
            function sendMobileReaction(reactionType) {
                return fetch('/api/reactions', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'X-XSRF-TOKEN': getCsrfToken()
                    },
                    body: JSON.stringify({ dishId: currentDishId, reactionType: reactionType, date: currentDate })
                })
                .then(res => {
                    if (res.redirected) {
                        window.location.href = res.url;
                        return null;
                    }
                    if (!res.ok) {
                        return res.json().then(errorData => {
                            throw new Error(errorData.error || `HTTP ${res.status}: ${res.statusText}`);
                        }).catch(() => {
                            throw new Error(`HTTP ${res.status}: ${res.statusText}`);
                        });
                    }
                    return res.json();
                })
                .then(data => {
                    if (!data) return;
                    updateMobileReactionIcon(data.userReactionType);
                    if (data.userReactionType) {
                        mobileReactionText.textContent = getReactionText(data.userReactionType);
                        mobileReactionText.className = 'font-medium text-base ml-1 ' + getReactionColorClass(data.userReactionType);
                    } else {
                        mobileReactionText.textContent = 'Good';
                        mobileReactionText.className = 'font-medium text-base ml-1 text-gray-600';
                    }
                });
            }

            function handleMobileQuickTap() {
                const isAuthenticated = /*[[${isAuthenticated}]]*/ false;
                if (!isAuthenticated) {
                    var currentUrl = window.location.pathname + window.location.search + window.location.hash;
                    document.cookie = "redirectAfterLogin=" + encodeURIComponent(currentUrl) + "; path=/";
                    window.location.href = '/login';
                    return;
                }
                const currentReactionType = mobileReactionIcon.dataset.reactionType;
                const typeToSend = (currentReactionType === 'NONE' || currentReactionType === null) ? 'GOOD' : currentReactionType;
                sendMobileReaction(typeToSend)
                .catch(error => {
                    console.error('Error submitting reaction:', error);
                    alert('Failed to submit reaction. Please try again. Error: ' + error.message);
                });
            }

            // Capture-phase click listener to suppress default click after long-press
            mobileReactionBtn.addEventListener('click', function(e) {
                if (suppressMobileClick) {
                    e.preventDefault();
                    e.stopImmediatePropagation();
                    suppressMobileClick = false;
                }
            }, true);

            mobileReactionBtn.addEventListener('touchstart', function(e) {
                if (!e.touches || e.touches.length === 0) return;
                e.preventDefault(); // prevent text selection/callout
                const t = e.touches[0];
                touchStartX = t.clientX;
                touchStartY = t.clientY;
                mobileLongPressTriggered = false;
                mobileReactionBtn.classList.add('mobile-touch-active');
                clearTimeout(mobileLongPressTimer);
                mobileLongPressTimer = setTimeout(function() {
                    mobileLongPressTriggered = true;
                    suppressMobileClick = true;
                    mobileReactionMenu.classList.remove('hidden');
                    menuSelectionArmed = false; // opened via long-press; ignore immediate lift
                    // Clear any accidental text selection on long-press
                    try {
                        const sel = document.getSelection && document.getSelection();
                        if (sel && sel.removeAllRanges) sel.removeAllRanges();
                    } catch (err) { /* ignore */ }
                }, LONG_PRESS_MS);
            }, { passive: false });
            
            mobileReactionBtn.addEventListener('touchmove', function(e) {
                if (!e.touches || e.touches.length === 0) return;
                const t = e.touches[0];
                const dx = Math.abs(t.clientX - touchStartX);
                const dy = Math.abs(t.clientY - touchStartY);
                if (dx > MOVE_TOLERANCE_PX || dy > MOVE_TOLERANCE_PX) {
                    clearTimeout(mobileLongPressTimer);
                }
            }, { passive: true });

            function clearMobileTouchState() {
                clearTimeout(mobileLongPressTimer);
                mobileReactionBtn.classList.remove('mobile-touch-active');
            }

            mobileReactionBtn.addEventListener('touchend', function() {
                clearMobileTouchState();
                if (mobileLongPressTriggered) {
                    // Keep menu open and suppress the immediate click generated by touchend
                    setTimeout(function() {
                        mobileLongPressTriggered = false;
                        suppressMobileClick = false;
                    }, 350);
                } else {
                    // Quick tap path
                    lastQuickTapTs = Date.now();
                    handleMobileQuickTap();
                }
            }, { passive: true });

            mobileReactionBtn.addEventListener('touchcancel', function() {
                clearMobileTouchState();
                mobileLongPressTriggered = false;
                suppressMobileClick = false;
            }, { passive: true });

            // Touch feedback for emoji options
            if (mobileReactionMenu) {
                mobileReactionMenu.addEventListener('touchstart', function(e) {
                    const option = e.target.closest('.reaction-option');
                    if (option) option.classList.add('touch-active');
                    menuSelectionArmed = true; // arm selection only after explicit touch in menu
                }, { passive: true });
                ['touchend','touchcancel'].forEach(function(evt) {
                    mobileReactionMenu.addEventListener(evt, function(e) {
                        const option = e.target.closest('.reaction-option');
                        if (option) option.classList.remove('touch-active');
                    }, { passive: true });
                });

                // Direct emoji selection on touch
                mobileReactionMenu.addEventListener('touchend', function(e) {
                    if (!menuSelectionArmed) return; // ignore lift from long-press
                    const reactionOption = e.target.closest('.reaction-option');
                    if (!reactionOption) return;
                    e.preventDefault();
                    e.stopPropagation();
                    lastQuickTapTs = Date.now();

                    // Check if user is authenticated first
                    const isAuthenticated = /*[[${isAuthenticated}]]*/ false;
                    if (!isAuthenticated) {
                        var currentUrl = window.location.pathname + window.location.search + window.location.hash;
                        document.cookie = "redirectAfterLogin=" + encodeURIComponent(currentUrl) + "; path=/";
                        window.location.href = '/login';
                        return;
                    }

                    const reactionType = reactionOption.dataset.reaction;
                    sendMobileReaction(reactionType)
                    .catch(error => {
                        console.error('Error submitting reaction:', error);
                        alert('Failed to submit reaction. Please try again. Error: ' + error.message);
                    })
                    .finally(() => {
                        mobileReactionMenu.classList.add('hidden');
                        menuSelectionArmed = false;
                    });
                }, { passive: false });
            }

            // Outside-tap dismissal for mobile reaction menu
            function isOutsideMobileReaction(target) {
                return mobileReactionMenu && !mobileReactionMenu.contains(target) && !mobileReactionBtn.contains(target);
            }
            ;['touchstart','click'].forEach(function(evt) {
                document.addEventListener(evt, function(e) {
                    if (!mobileReactionMenu || mobileReactionMenu.classList.contains('hidden')) return;
                    if (isOutsideMobileReaction(e.target)) {
                        mobileReactionMenu.classList.add('hidden');
                        menuSelectionArmed = false;
                    }
                }, { passive: true, capture: true });
            });
            // Escape to close
            document.addEventListener('keydown', function(e) {
                if (e.key === 'Escape' && mobileReactionMenu && !mobileReactionMenu.classList.contains('hidden')) {
                    mobileReactionMenu.classList.add('hidden');
                    menuSelectionArmed = false;
                }
            });

            // Handle direct click on mobile reaction button
            mobileReactionBtn.addEventListener('click', function(e) {
                // Ignore if a touch quick tap just fired
                if (Date.now() - lastQuickTapTs < 400) {
                    e.preventDefault();
                    return;
                }
                // Check if user is authenticated first
                const isAuthenticated = /*[[${isAuthenticated}]]*/ false;
                if (!isAuthenticated) {
                    // Save current URL in a cookie and redirect to login
                    var currentUrl = window.location.pathname + window.location.search + window.location.hash;
                    document.cookie = "redirectAfterLogin=" + encodeURIComponent(currentUrl) + "; path=/";
                    window.location.href = '/login';
                    return;
                }

                const currentReactionType = mobileReactionIcon.dataset.reactionType;
                
                // If no reaction is selected, set Good reaction
                if (currentReactionType === 'NONE' || currentReactionType === null) {
                    // Send request to set Good reaction
                    fetch('/api/reactions', {
                        method: 'POST',
                        headers: { 
                            'Content-Type': 'application/json',
                            'X-XSRF-TOKEN': getCsrfToken()
                        },
                        body: JSON.stringify({ dishId: currentDishId, reactionType: 'GOOD', date: currentDate })
                    })
                    .then(res => {
                        if (res.redirected) {
                            // Handle redirect to login
                            window.location.href = res.url;
                            return;
                        }
                        if (!res.ok) {
                            return res.json().then(errorData => {
                                throw new Error(errorData.error || `HTTP ${res.status}: ${res.statusText}`);
                            }).catch(() => {
                                throw new Error(`HTTP ${res.status}: ${res.statusText}`);
                            });
                        }
                        return res.json();
                    })
                    .then(data => {
                        if (data) { // Only process if we got data (not redirected)
                            
                            // Update main reaction button icon
                            updateMobileReactionIcon(data.userReactionType);
                            
                            // Update text based on user reaction
                            if (data.userReactionType) {
                                mobileReactionText.textContent = getReactionText(data.userReactionType);
                                mobileReactionText.className = 'font-medium text-base ml-1 ' + getReactionColorClass(data.userReactionType);
                            } else {
                                mobileReactionText.textContent = 'Good';
                                mobileReactionText.className = 'font-medium text-base ml-1 text-gray-600';
                            }
                        }
                    })
                    .catch(error => {
                        console.error('Error submitting reaction:', error);
                        alert('Failed to submit reaction. Please try again. Error: ' + error.message);
                    });
                } else {
                    // If reaction is already selected, remove it by sending the same reaction type
                    fetch('/api/reactions', {
                        method: 'POST',
                        headers: { 
                            'Content-Type': 'application/json',
                            'X-XSRF-TOKEN': getCsrfToken()
                        },
                        body: JSON.stringify({ dishId: currentDishId, reactionType: currentReactionType, date: currentDate })
                    })
                    .then(res => {
                        if (res.redirected) {
                            // Handle redirect to login
                            window.location.href = res.url;
                            return;
                        }
                        if (!res.ok) {
                            return res.json().then(errorData => {
                                throw new Error(errorData.error || `HTTP ${res.status}: ${res.statusText}`);
                            }).catch(() => {
                                throw new Error(`HTTP ${res.status}: ${res.statusText}`);
                            });
                        }
                        return res.json();
                    })
                    .then(data => {
                        if (data) { // Only process if we got data (not redirected)
                            updateMobileReactionIcon(data.userReactionType);
                            updateReactionTextAndStyle(data.userReactionType, false);
                        }
                    })
                    .catch(error => {
                        console.error('Error removing reaction:', error);
                        alert('Failed to remove reaction. Please try again. Error: ' + error.message);
                    });
                }
            });

            // Handle reaction option clicks directly
            mobileReactionMenu.addEventListener('click', function(e) {
                // Skip if this click immediately follows a touch selection
                if (Date.now() - lastQuickTapTs < 400) {
                    e.preventDefault();
                    return;
                }
                if (!menuSelectionArmed) return; // require explicit menu interaction
                const reactionOption = e.target.closest('.reaction-option');
                if (!reactionOption) return;

                // Check if user is authenticated first
                const isAuthenticated = /*[[${isAuthenticated}]]*/ false;
                if (!isAuthenticated) {
                    // Save current URL in a cookie and redirect to login
                    var currentUrl = window.location.pathname + window.location.search + window.location.hash;
                    document.cookie = "redirectAfterLogin=" + encodeURIComponent(currentUrl) + "; path=/";
                    window.location.href = '/login';
                    return;
                }

                const reactionType = reactionOption.dataset.reaction;
                const animation = reactionOption.dataset.animation;
                const text = reactionOption.dataset.text;
                const currentReactionType = mobileReactionIcon.dataset.reactionType;

                // Send request with the actual reaction type
                fetch('/api/reactions', {
                    method: 'POST',
                    headers: { 
                        'Content-Type': 'application/json',
                        'X-XSRF-TOKEN': getCsrfToken()
                    },
                    body: JSON.stringify({ dishId: currentDishId, reactionType: reactionType, date: currentDate })
                })
                .then(res => {
                    if (res.redirected) {
                        // Handle redirect to login
                        window.location.href = res.url;
                        return;
                    }
                    if (!res.ok) {
                        return res.json().then(errorData => {
                            throw new Error(errorData.error || `HTTP ${res.status}: ${res.statusText}`);
                        }).catch(() => {
                            throw new Error(`HTTP ${res.status}: ${res.statusText}`);
                        });
                    }
                    return res.json();
                })
                .then(data => {
                    if (data) { // Only process if we got data (not redirected)
                        updateMobileReactionIcon(data.userReactionType);
                        updateReactionTextAndStyle(data.userReactionType, false);
                    }
                })
                .catch(error => {
                    console.error('Error submitting reaction:', error);
                    alert('Failed to submit reaction. Please try again. Error: ' + error.message);
                });

                // Hide menu after selection
                mobileReactionMenu.classList.add('hidden');
                menuSelectionArmed = false;
            });
        }

        function updateMobileReactionIcon(userReactionType) {
            if (!mobileReactionIcon || !mobileMainReactionAnim) return;
            
            // Update the main reaction button animation
            if (userReactionType) {
                const animationMap = {
                    'GOOD': '/images/reaction-menus/good.json',
                    'OKAY': '/images/reaction-menus/okayish.json',
                    'NOT_GONNA_WORK': '/images/reaction-menus/not-gonna-work.json',
                    'NEEDS_IMPROVEMENT': '/images/reaction-menus/needs-improvement.json'
                };
                const newPath = animationMap[userReactionType] || '/images/reaction-menus/good.json';
                
                // Destroy and recreate animation with new path
                mobileMainReactionAnim.destroy();
                const container = document.getElementById('mobile-main-reaction-animation');
                mobileMainReactionAnim = lottie.loadAnimation({
                    container: container,
                    renderer: 'svg',
                    loop: true,
                    autoplay: true,
                    path: newPath
                });
                
                mobileReactionIcon.dataset.reactionType = userReactionType;
            } else {
                // Reset to default animation
                mobileMainReactionAnim.destroy();
                const container = document.getElementById('mobile-main-reaction-animation');
                mobileMainReactionAnim = lottie.loadAnimation({
                    container: container,
                    renderer: 'svg',
                    loop: true,
                    autoplay: true,
                    path: '/images/reaction-menus/good.json'
                });
                
                mobileReactionIcon.dataset.reactionType = 'NONE';
            }
        }

        // Mobile comments modal functionality - only for authenticated users
        const mobileCommentsBtn = document.getElementById('mobile-comments-btn');
        const mobileCommentsModal = document.getElementById('mobile-comments-modal');
        const closeCommentsModal = document.getElementById('close-comments-modal');
        const mobileCommentsList = document.getElementById('mobile-comments-list');
        const mobileCommentForm = document.getElementById('mobile-comment-form');

        if (isAuthenticated && mobileCommentsBtn && mobileCommentsModal && mobileCommentsList && mobileCommentForm) {
            mobileCommentsBtn.addEventListener('click', function() {
                // Show modal with animation
                mobileCommentsModal.classList.remove('hidden');
                // Force a reflow to ensure the hidden class is removed before animation
                mobileCommentsModal.offsetHeight;
                // Trigger the slide-up animation
                const modalContent = mobileCommentsModal.querySelector('.transform');
                modalContent.style.transform = 'translateY(0)';
                
                // Reset page and load comments for the modal
                currentPage = 0;
                loadMobileComments(true);
            });

            closeCommentsModal.addEventListener('click', function() {
                // Trigger slide-down animation
                const modalContent = mobileCommentsModal.querySelector('.transform');
                modalContent.style.transform = 'translateY(100%)';
                
                // Hide modal after animation completes
                setTimeout(() => {
                    mobileCommentsModal.classList.add('hidden');
                }, 300);
            });

            // Close modal when clicking outside with animation
            mobileCommentsModal.addEventListener('click', function(e) {
                if (e.target === mobileCommentsModal) {
                    // Trigger slide-down animation
                    const modalContent = mobileCommentsModal.querySelector('.transform');
                    modalContent.style.transform = 'translateY(100%)';
                    
                    // Hide modal after animation completes
                    setTimeout(() => {
                        mobileCommentsModal.classList.add('hidden');
                    }, 300);
                }
            });

            // Handle form submission
            mobileCommentForm.addEventListener('submit', async function(e) {
                e.preventDefault();
                
                // Check if user is authenticated
                const isAuthenticated = /*[[${isAuthenticated}]]*/ false;
                if (!isAuthenticated) {
                    // Save current URL in a cookie and redirect to login
                    var currentUrl = window.location.pathname + window.location.search + window.location.hash;
                    document.cookie = "redirectAfterLogin=" + encodeURIComponent(currentUrl) + "; path=/";
                    window.location.href = '/login';
                    return false;
                }
                
                const commentInput = this.querySelector('input[name="comment"]');
                const commentText = commentInput.value;
                
                if (!commentText.trim()) {
                    alert('Comment cannot be empty.');
                    return;
                }
                
                const formData = new FormData(this);
                try {
                    const res = await fetch('/weekly-feedback/feedback', {
                        method: 'POST',
                        body: formData
                    });
                    
                    if (res.ok) {
                        // Clear the input
                        commentInput.value = '';
                        
                        // Update comment count instantly
                        const commentCountElement = document.querySelector('#mobile-comments-btn span');
                        if (commentCountElement) {
                            const currentCount = parseInt(commentCountElement.textContent, 10);
                            commentCountElement.textContent = currentCount + 1;
                        }
                        
                        // Reload comments to show the new comment
                        currentPage = 0;
                        loadMobileComments(true);
                        
                    } else {
                        const errorData = await res.json();
                        alert(errorData.message || 'Failed to submit comment.');
                    }
                } catch (error) {
                    console.error('Error submitting comment:', error);
                    alert('Failed to submit comment. Please try again.');
                }
            });
        }
    });

    

    // --- Desktop comment form guest login redirect ---
    const feedbackForm = document.querySelector('#feedback-form form');
    if (feedbackForm) {
        feedbackForm.addEventListener('submit', function(e) {
            // Authentication is already checked in the template, so this is just for safety
            const isAuthenticated = /*[[${isAuthenticated}]]*/ false;
            if (!isAuthenticated) {
                e.preventDefault();
                var currentUrl = window.location.pathname + window.location.search + window.location.hash;
                document.cookie = "redirectAfterLogin=" + encodeURIComponent(currentUrl) + "; path=/";
                window.location.href = '/login';
                return false;
            }
        });
    }

    // --- Desktop comment input guest login redirect on keyup ---
    const feedbackFormInput = document.querySelector('#feedback-form input[name="comment"]');
    if (feedbackFormInput) {
        feedbackFormInput.addEventListener('keyup', function(e) {
            const isAuthenticated = /*[[${isAuthenticated}]]*/ false;
            if (!isAuthenticated) {
                var currentUrl = window.location.pathname + window.location.search + window.location.hash;
                document.cookie = "redirectAfterLogin=" + encodeURIComponent(currentUrl) + "; path=/";
                window.location.href = '/login';
            }
        });
    }

    // Scroll active tab into view after page load and after navigation
    scrollActiveTabIntoView();
    
    // Also scroll active tab into view when window is resized (orientation change)
    window.addEventListener('resize', function() {
        setTimeout(scrollActiveTabIntoView, 100); // Small delay to ensure DOM is updated
    });
    /*]]>*/
    </script>
    <style>
        /* Custom scrollbar for comments list */
        #comments-list {
            scrollbar-width: thin;
            scrollbar-color: #3B82F6 #F3F4F6;
        }
        #comments-list::-webkit-scrollbar {
            width: 8px;
            background: #F3F4F6;
            border-radius: 8px;
        }
        #comments-list::-webkit-scrollbar-thumb {
            background: #3B82F6;
            border-radius: 8px;
        }
        
        /* Hide scrollbar for mobile dish tabs */
        .scrollbar-hide {
            -ms-overflow-style: none;  /* Internet Explorer 10+ */
            scrollbar-width: none;  /* Firefox */
        }
        .scrollbar-hide::-webkit-scrollbar {
            display: none;  /* Safari and Chrome */
        }
        
        /* Ensure smooth scrolling is disabled for mobile dish tabs */
        #mobile-dish-tabs {
            scroll-behavior: auto;
        }
        
        /* Facebook-style reaction system */
        .reaction-option {
            position: relative;
            overflow: hidden;
        }
        
        .reaction-option:hover {
            transform: scale(1.25);
            z-index: 10;
        }
        
        .reaction-option span {
            display: inline-block;
            transition: all 0.2s ease;
        }
        
        .reaction-option:hover span {
            animation: bounce 0.3s ease;
        }
        
        @keyframes bounce {
            0%, 100% { transform: translateY(0); }
            50% { transform: translateY(-2px); }
        }
        
        /* Reaction menu positioning and visibility */
        #reaction-menu, #mobile-reaction-menu {
            opacity: 0;
            transform: scale(0.8) translateY(10px);
            transition: all 0.2s ease;
            pointer-events: none;
        }
        
        #reaction-menu:not(.hidden), #mobile-reaction-menu:not(.hidden) {
            opacity: 1;
            transform: scale(1) translateY(0);
            pointer-events: auto;
        }
        
        /* Reaction icon animations */
        #reaction-icon, #mobile-reaction-icon {
            transition: all 0.2s ease;
        }
        
        #reaction-icon:hover, #mobile-reaction-icon:hover {
            transform: scale(1.1);
        }
        
        /* Mobile responsive adjustments */
        @media (max-width: 768px) {
            #main-content {
                padding-top: 0; /* Remove extra padding since we have mt-32 */
            }
            
            /* Mobile Comments Modal - Instagram-style bottom sheet */
            #mobile-comments-modal {
                backdrop-filter: blur(4px);
                -webkit-backdrop-filter: blur(4px);
            }
            
            #mobile-comments-modal .transform {
                transform: translateY(100%);
            }
            
            #mobile-comments-modal:not(.hidden) .transform {
                transform: translateY(0);
            }
            
            /* Modal content responsive sizing */
            #mobile-comments-modal .max-h-\[85vh\] {
                max-height: 85vh;
                min-height: 40vh;
            }
            
            /* Better spacing for smaller screens */
            @media (max-height: 600px) {
                #mobile-comments-modal .max-h-\[85vh\] {
                    max-height: 90vh;
                    min-height: 50vh;
                }
            }
            
            /* Very small screens */
            @media (max-height: 500px) {
                #mobile-comments-modal .max-h-\[85vh\] {
                    max-height: 95vh;
                    min-height: 60vh;
                }
            }
            
            /* Mobile comments list styling */
            #mobile-comments-list {
                scrollbar-width: thin;
                scrollbar-color: #3B82F6 #F3F4F6;
                scroll-behavior: smooth;
                /* Add padding for scroll indicator */
                padding-bottom: 1rem;
            }
            #mobile-comments-list::-webkit-scrollbar {
                width: 6px;
                background: #F3F4F6;
                border-radius: 3px;
            }
            #mobile-comments-list::-webkit-scrollbar-thumb {
                background: #3B82F6;
                border-radius: 3px;
                min-height: 30px;
            }
            #mobile-comments-list::-webkit-scrollbar-thumb:hover {
                background: #2563EB;
            }
            
            /* Scroll indicator styling */
            #mobile-scroll-indicator {
                pointer-events: none;
                z-index: 10;
            }
            
            /* Better visual separation for comment items */
            #mobile-comments-list .comment-item {
                padding: 0.75rem 0;
                border-bottom: 1px solid #F3F4F6;
                transition: background-color 0.2s ease;
            }
            
            #mobile-comments-list .comment-item:last-child {
                border-bottom: none;
            }
            
            /* Loading state for many comments */
            .comments-loading {
                display: flex;
                align-items: center;
                justify-content: center;
                padding: 2rem;
                color: #6B7280;
            }
            
            .comments-loading .spinner {
                width: 20px;
                height: 20px;
                border: 2px solid #E5E7EB;
                border-top: 2px solid #3B82F6;
                border-radius: 50%;
                animation: spin 1s linear infinite;
                margin-right: 0.5rem;
            }
            
            @keyframes spin {
                0% { transform: rotate(0deg); }
                100% { transform: rotate(360deg); }
            }
            
            /* Instagram-style mobile post layout */
            .mobile-dish-post {
                max-width: 100vw;
                margin: 0 auto;
                background: white;
                border-radius: 0;
            }
            
            /* Responsive image container - Instagram style */
            .mobile-dish-image {
                width: 100% !important;
                height: 100% !important;
                object-fit: cover !important;
                display: block !important;
            }
            
            /* Image container responsive sizing */
            .mobile-dish-post .w-full[style*="aspect-ratio"] {
                width: 100%;
                min-height: 250px;
                max-height: 400px;
            }
            
            /* Content spacing - Instagram style */
            .mobile-dish-post .px-4 {
                padding-left: 1rem;
                padding-right: 1rem;
            }
            
            .mobile-dish-post .py-3 {
                padding-top: 0.75rem;
                padding-bottom: 0.75rem;
            }
            
            /* Typography improvements */
            .mobile-dish-title {
                font-size: 1.125rem !important;
                font-weight: 700 !important;
                line-height: 1.4 !important;
                color: #111827 !important;
            }
            
            .mobile-dish-description {
                font-size: 0.875rem !important;
                line-height: 1.5 !important;
                color: #374151 !important;
            }
            
            /* Better text sizing for smaller screens */
            @media (max-width: 480px) {
                .mobile-dish-post .px-4 {
                    padding-left: 0.875rem;
                    padding-right: 0.875rem;
                }
                
                .mobile-dish-title {
                    font-size: 1rem !important;
                    line-height: 1.3 !important;
                }
                
                .mobile-dish-description {
                    font-size: 0.8125rem !important;
                    line-height: 1.4 !important;
                }
                
                .mobile-dish-post .w-full[style*="aspect-ratio"] {
                    min-height: 200px;
                    max-height: 350px;
                }
                
                /* Smaller modal on very small screens */
                #mobile-comments-modal .max-h-\[85vh\] {
                    min-height: 45vh;
                }
            }
            
            /* Very small screens (iPhone SE, etc.) */
            @media (max-width: 375px) {
                .mobile-dish-post .px-4 {
                    padding-left: 0.75rem;
                    padding-right: 0.75rem;
                }
                
                .mobile-dish-tabs {
                    padding-left: 0.75rem;
                    padding-right: 0.75rem;
                }
                
                .mobile-dish-post .w-full[style*="aspect-ratio"] {
                    min-height: 180px;
                    max-height: 320px;
                }
            }
            
            /* Landscape orientation on mobile */
            @media (max-height: 500px) and (orientation: landscape) {
                .mobile-dish-post .w-full[style*="aspect-ratio"] {
                    aspect-ratio: 16/9 !important;
                    max-height: 40vh;
                    min-height: 150px;
                }
                
                .mobile-dish-post {
                    padding-bottom: 1rem;
                }
                
                /* Adjust modal for landscape */
                #mobile-comments-modal .max-h-\[85vh\] {
                    max-height: 95vh;
                    min-height: 70vh;
                }
            }
            
            /* Large mobile screens (iPhone Plus, etc.) */
            @media (min-width: 414px) and (max-width: 768px) {
                .mobile-dish-title {
                    font-size: 1.25rem !important;
                }
                
                .mobile-dish-description {
                    font-size: 0.9375rem !important;
                }
                
                .mobile-dish-post .w-full[style*="aspect-ratio"] {
                    min-height: 280px;
                    max-height: 450px;
                }
            }

            /* Touch feedback styles for mobile */
            .mobile-touch-active {
                background-color: rgba(0, 0, 0, 0.06);
                border-radius: 9999px;
            }
            .reaction-option.touch-active {
                background-color: #e5e7eb;
            }

            /* Prevent long-press selection/callout on mobile reaction button */
            #mobile-reaction-btn,
            #mobile-reaction-btn * {
                -webkit-user-select: none;
                user-select: none;
                -webkit-touch-callout: none;
                -webkit-tap-highlight-color: transparent;
                touch-action: manipulation;
            }
        }
    </style>
</body>
</html> 